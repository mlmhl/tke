import {
  line,
  Selection,
  BaseType,
  Line as LineInterface,
  NestedArray,
  ScalePoint,
  select,
} from "d3";
import { Context } from "../../context";
import { RectCoordinate } from "../../coordinate/rect";
import { Color } from "../../../type";
import { Shape } from "../shape";
import { LegendData } from "../../legend/legend";

export class Line extends Shape {
  /**
   * 绑定的坐标实例
   */
  private coordinate: RectCoordinate;

  /**
   * 折线对象
   */
  private line: Selection<SVGGElement, {}, BaseType, {}>;

  /**
   * 线的粗细
   */
  private lineWidth: number = 3;

  public constructor(ctx: Context, coordinate: RectCoordinate) {
    super(ctx);
    this.coordinate = coordinate;
    this.line = this.ctx.plot.selection.append("g").lower();
    this.coordinate.xAxis.lower();
    this.coordinate.yAxis.lower();

    this.ctx.on("coordinate.helper.show", this.showHoverPoint.bind(this));
    this.ctx.on("coordinate.helper.hide", this.hideHoverPoint.bind(this));
    this.ctx.on("legend.hover", this.onLegendItemHover.bind(this));
    this.ctx.on("legend.left", this.onLegendItemLeft.bind(this));
  }

  /**
   * 设置数据映射
   * @param pos 同 chart.position
   */
  public position(pos: string) {
    if (typeof pos === "string") {
      const [xName, yName] = pos.split("*");
      this.coordinate.setPosition(xName, yName);
    }
    return this;
  }

  /**
   * 以颜色来作为数据映射
   * @param color 字段名
   */
  public color(color: string | Color) {
    if (color) {
      if (typeof color === "string") {
        this.coordinate.setSerie(color);
      } else if (typeof color === "object" && color.key) {
        const { key, formatter, colors } = color;
        this.coordinate.setSerie(key);
        if (formatter || colors) {
          this.ctx.theme.color = formatter || colors;
        }
      }
    }
    return this;
  }

  /**
   * 设置线条的粗细
   * @param size 粗细值
   */
  public size(size: number) {
    this.lineWidth = size;
    return this;
  }

  /**
   * 设置坐标轴配置
   * @param axis 坐标轴配置
   */
  public axis(axis: Context["axis"]) {
    const newCfg: Context["axis"] = {};
    for (const axisName in axis) {
      if (Object.prototype.hasOwnProperty.call(axis, axisName)) {
        const cfg = axis[axisName];
        newCfg[axisName] = Object.assign({}, this.ctx.axis[axisName], cfg);
      }
    }
    this.ctx.setAxis(newCfg);
    return this;
  }

  /**
   * 开始绘图
   *
   * @param highlightIndex 高亮的索引值
   */
  public draw(highlightIndex?: number) {
    const { xScale, yScale, xKey, yKey, nestedData } = this.coordinate;

    // @ts-ignore
    const lineInstance = (line as LineInterface<number>)()
      .defined(d => typeof d[yKey] === "number")
      .y(d => yScale(d[yKey]))
      .x(d => (xScale as ScalePoint<string>)(d[xKey]));

    this.line
      .attr("fill", "none")
      .attr("stroke-linejoin", "round")
      .attr("stroke-linecap", "round")
      .selectAll("path")
      .data(nestedData)
      .join("path")
      .attr("stroke", (d, i) => {
        if (highlightIndex === undefined || highlightIndex === i) {
          return d.value;
        }
        return "#ECECEC";
      })
      .attr("stroke-width", this.lineWidth)
      .attr("d", d => lineInstance(d.values))
      .call(g => {
        // 将高亮的线放置最前端
        g.each(function order(_, index) {
          if (index === highlightIndex) {
            select(this).raise();
          }
        });
      });

    this.drawHoverPoint();

    return this;
  }

  /**
   * 绘制辅助点
   */
  private drawHoverPoint() {
    const { helperLayout, nestedData } = this.coordinate;

    helperLayout
      .append("path")
      .attr("class", "hover-line")
      .style("stroke", "#ECECEC")
      .style("stroke-width", 1)
      .style("opacity", "0");

    const hoverHelper = helperLayout
      .selectAll(".line-hover-helper")
      .data(nestedData)
      .join("g")
      .attr("class", "line-hover-helper");

    hoverHelper.selectAll("circle").remove();

    hoverHelper
      .append("circle")
      .attr("r", 4)
      .style("stroke", d => d.value)
      .style("fill", "#FFF")
      .style("stroke-width", 2)
      .style("opacity", "0");
  }

  /**
   * 显示辅助点
   * @param xPos x 坐标
   * @param index 行索引
   */
  private showHoverPoint({ xPos, index }) {
    const { helperLayout, yScale, yKey } = this.coordinate;

    helperLayout
      .select(".hover-line")
      .attr("d", () => {
        return `M${xPos},${this.ctx.plot.height} ${xPos},0`;
      })
      .style("opacity", "1");

    helperLayout
      .selectAll(".line-hover-helper circle")
      .style(
        "opacity",
        (d: NestedArray<{ [key: string]: number | string }, null>) => {
          const value = d.values[index][yKey];
          return value === null ? "0" : "1";
        }
      );

    helperLayout
      .selectAll(".line-hover-helper")
      .attr(
        "transform",
        (d: NestedArray<{ [key: string]: number | string }, null>) => {
          const yPos = yScale(d.values[index][yKey]);
          return `translate(${xPos},${yPos})`;
        }
      );
  }

  /**
   * 隐藏辅助点
   */
  private hideHoverPoint() {
    this.coordinate.helperLayout
      .selectAll(".line-hover-helper circle")
      .style("opacity", "0");
    this.coordinate.helperLayout.select(".hover-line").style("opacity", "0");
  }

  private onLegendItemHover(legendData: LegendData) {
    const { index } = legendData;
    this.draw(index);
  }

  private onLegendItemLeft() {
    this.draw();
  }
}
