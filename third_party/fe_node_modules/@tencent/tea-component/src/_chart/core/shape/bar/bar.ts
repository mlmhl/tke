import { Selection, BaseType, select, ScaleBand } from "d3";
import { Shape } from "../shape";
import { Context } from "../../context";
import { RectCoordinate } from "../../coordinate/rect";
import { Color } from "../../../type";
import { LegendData } from "../../legend/legend";

export class Bar extends Shape {
  /**
   * 绑定的坐标实例
   */
  private coordinate: RectCoordinate;

  /**
   * 折线对象
   */
  private bar: Selection<SVGGElement, {}, BaseType, {}>;

  private barWidth: number;

  public constructor(ctx: Context, coordinate: RectCoordinate) {
    super(ctx);
    this.coordinate = coordinate;
    this.bar = this.ctx.plot.selection
      .append("g")
      .attr("class", "shape-bar")
      .lower();
    this.coordinate.xAxis.lower();
    this.coordinate.yAxis.lower();
    this.coordinate.setXScaleType("Band");
    this.coordinate.helperLayout
      .append("rect")
      .attr("class", "hover-band")
      .style("fill", "#000")
      .style("opacity", "0");

    this.ctx.on("coordinate.helper.show", this.showHoverBand.bind(this));
    this.ctx.on("coordinate.helper.hide", this.hideHoverBand.bind(this));
    this.ctx.on("legend.hover", this.onLegendItemHover.bind(this));
    this.ctx.on("legend.left", this.onLegendItemLeft.bind(this));
  }

  public position(pos: string) {
    if (typeof pos === "string") {
      const [xName, yName] = pos.split("*");
      this.coordinate.setPosition(xName, yName);
    }
    return this;
  }

  public size(size: number) {
    this.barWidth = size;
    return this;
  }

  public color(color: string | Color) {
    if (color) {
      if (typeof color === "string") {
        this.coordinate.setSerie(color);
      } else if (typeof color === "object" && color.key) {
        const { key, formatter, colors } = color;
        this.coordinate.setSerie(key);
        if (formatter || colors) {
          this.ctx.theme.color = formatter || colors;
        }
      }
    }
    return this;
  }

  public axis(axis: Context["axis"]) {
    const newCfg: Context["axis"] = {};
    for (const axisName in axis) {
      if (Object.prototype.hasOwnProperty.call(axis, axisName)) {
        const cfg = axis[axisName];
        newCfg[axisName] = Object.assign({}, this.ctx.axis[axisName], cfg);
      }
    }
    this.ctx.setAxis(newCfg);
    return this;
  }

  public draw(highlightIndex?: number) {
    const { xScale, yScale, xKey, yKey, nestedData } = this.coordinate;
    const axisScale = xScale[0];
    const serieScale = xScale[1];
    const data = this.ctx.dataSource;

    const cats = this.bar
      .selectAll("g")
      .data(data)
      .join("g")
      .attr(
        "transform",
        d => `translate(${axisScale(d[xKey] as string) || 0},0)`
      );

    cats.nodes().forEach((cat, index) => {
      select(cat)
        .selectAll("rect")
        .data(nestedData)
        .join("rect")
        .attr("fill", (d, i) => {
          if (highlightIndex === undefined || highlightIndex === i) {
            return d.value;
          }
          return "#ECECEC";
        })
        .attr("width", this.barWidth || serieScale.bandwidth())
        .attr("x", d => serieScale(d.key))
        .attr("y", d => {
          const row = d.values[index] || {};
          return yScale(row[yKey] || 0);
        })
        .attr("height", d => {
          const row = d.values[index] || {};
          return yScale(0) - yScale(row[yKey] || 0);
        });
    });

    return this;
  }

  private showHoverBand({ xPos }) {
    const { height } = this.ctx.plot;
    const { xScale, helperLayout } = this.coordinate;
    const [axisScale] = xScale as ScaleBand<string>[];
    const bandwidth = axisScale.bandwidth();
    const padding = axisScale.padding() * bandwidth;
    const width = bandwidth < padding ? bandwidth : bandwidth + padding;

    const x = bandwidth < padding ? xPos : xPos - padding / 2;

    helperLayout
      .select(".hover-band")
      .attr("width", width)
      .attr("height", height)
      .attr("transform", `translate(${x},0)`)
      .style("opacity", "0.05");
  }

  private hideHoverBand() {
    this.coordinate.helperLayout.selectAll(".hover-band").style("opacity", "0");
  }

  private onLegendItemHover(legendData: LegendData) {
    const { index } = legendData;
    this.draw(index);
  }

  private onLegendItemLeft() {
    this.draw();
  }
}
