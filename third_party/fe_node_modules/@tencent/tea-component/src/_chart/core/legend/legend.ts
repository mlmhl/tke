import { Selection, BaseType, NestedArray } from "d3";
import { Context } from "../context";
import { nodeWidth } from "../lib/svg-helper";

export interface LegendData {
  label: string;
  color: string;
  index: number;
  key: string;
  raw: {
    key: string;
    values:
      | NestedArray<
          {
            [key: string]: string | number;
          },
          string
        >
      | {
          [key: string]: string | number;
        }[];
    value: string;
  };
}

export class Legend {
  /**
   * 上下文
   */
  private ctx: Context;

  /**
   * 图例对象
   */
  private legend: Selection<SVGGElement, {}, BaseType, {}>;

  /**
   * 不显示的数据系列
   */
  private disabledKeys: string[] = [];

  public constructor(ctx: Context) {
    this.ctx = ctx;
    const {
      height,
      padding: { top, bottom },
    } = this.ctx.plot;
    this.legend = this.ctx.view
      .append("g")
      .classed("legend", true)
      .attr("transform", `translate(0,${height + top + bottom + 20})`);

    this.ctx.on("coordinate-updated", this.updateLegendData.bind(this));
  }

  private updateLegendData(
    nestData: NestedArray<{ [key: string]: number | string }, null>,
    yKey: string
  ) {
    if (!this.ctx.legend.enable) return;
    const alias = this.ctx.scale[yKey] && this.ctx.scale[yKey].alias;
    const legendData: LegendData[] = [];

    for (const [i, d] of nestData.entries()) {
      const label = alias || (d.key === "undefined" ? yKey : d.key);
      legendData.push({
        label,
        color: d.value,
        index: i,
        raw: d,
        key: d.key,
      });
    }

    this.draw(legendData);
  }

  /**
   * 绘制图例
   * @param nestData 结构化数据
   * @param yKey Y 轴映射字段名
   */
  private draw(legendData: LegendData[]) {
    const { rect, text } = this.ctx.theme.legend;
    this.legend.selectAll(".legend-item").remove();
    const items = this.legend
      .selectAll(".legend-item")
      .data(legendData, (d: LegendData) => d.label);
    const enter = items
      .enter()
      .append("g")
      .attr("class", "legend-item")
      .style("cursor", "pointer")
      .call(g => {
        g.append("rect")
          .attr("width", rect.width)
          .attr("height", rect.height)
          .attr("y", -text.fontSize / 2);
        g.append("text")
          .attr("x", rect.width + 5)
          .attr("font-size", `${text.fontSize}px`)
          .text((d, i) => {
            const { formatter } = this.ctx.legend;
            let text = d.label;
            if (formatter) {
              text = formatter(d.label, i, legendData.length - 1 === i);
            }
            return text;
          });
      });

    let offset = 0; // 每个图例的 X 偏移量
    items
      .merge(enter)
      .attr("transform", function setItemOffset() {
        const x = offset;
        offset += nodeWidth(this as SVGGraphicsElement) + 30;
        return `translate(${x}, 0)`;
      })
      .on("mouseenter", this.onLegendItemHover.bind(this))
      .on("mouseleave", this.onLegendItemLeft.bind(this))
      .on("click", this.onLegendItemClick.bind(this))
      .call(g => {
        g.selectAll("rect").attr("fill", (d: LegendData) =>
          this.disabledKeys.find(k => k === d.key)
            ? text.disabledColor
            : d.color
        );
        g.selectAll("text").attr("fill", (d: LegendData) =>
          this.disabledKeys.find(k => k === d.key)
            ? text.disabledColor
            : text.color
        );
      });

    this.setPosition();
  }

  /**
   * 当绘图区渲染完成之后，再定位 Legend 坐标
   */
  private setPosition() {
    this.legend.attr("transform", () => {
      const { width, height } = this.ctx.plot;
      const { top, bottom } = this.ctx.plot.padding;
      const legendWidth = nodeWidth(this.legend.node());
      const x = Math.floor(width / 2) - Math.floor(legendWidth / 2);
      return `translate(${x}, ${height + top + bottom + 20})`;
    });
  }

  private onLegendItemHover(legendData: LegendData) {
    // 被禁用的元素不需要触发 Hover 事件
    if (this.disabledKeys.includes(legendData.key)) return;
    this.ctx.emit("legend.hover", legendData);
  }

  private onLegendItemLeft(legendData: LegendData) {
    this.ctx.emit("legend.left", legendData);
  }

  private onLegendItemClick(legendData: LegendData) {
    const { key } = legendData;
    const disabled = this.disabledKeys.findIndex(k => k === key) !== -1;
    const data = this.legend.selectAll(".legend-item").data() as LegendData[];
    const index = data.findIndex(d => d.key === key);
    if (disabled) {
      this.disabledKeys = this.disabledKeys.filter(k => k !== key);
    } else {
      this.disabledKeys.push(key);
    }
    this.draw(data);
    this.ctx.emit("legend.clicked", data[index], !disabled);
    this.onLegendItemLeft(legendData);
  }
}
