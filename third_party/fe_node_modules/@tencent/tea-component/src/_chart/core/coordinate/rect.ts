import {
  ScalePoint,
  ScaleLinear,
  scalePoint,
  scaleLinear,
  Selection,
  BaseType,
  format,
  axisBottom,
  nest,
  range as d3Range,
  bisectRight,
  NestedArray,
  axisLeft,
  scaleBand,
  ScaleBand,
  scaleOrdinal,
  select,
} from "d3";
import { Context } from "../context";
import { getLabelMaxWidth } from "../lib/svg-helper";
import { LegendData } from "../legend/legend";

export class RectCoordinate {
  /**
   * 上下文
   */
  private ctx: Context;

  /**
   * X 轴映射字段
   */
  public xKey: string;

  /**
   * Y 轴映射字段
   */
  public yKey: string;

  /**
   * 数据系列映射字段
   */
  public serieKey: string;

  /**
   * X 轴比例尺类型
   */
  public XScaleType: "Band" | "Point" = "Point";

  /**
   * X 轴比例尺
   */
  public xScale: ScalePoint<string> | [ScaleBand<string>, ScaleBand<string>];

  /**
   * Y 轴比例尺
   */
  public yScale: ScaleLinear<number, number>;

  /**
   * X 轴实例对象
   */
  public xAxis: Selection<SVGGElement, {}, BaseType, {}>;

  /**
   * Y 轴实例对象
   */
  public yAxis: Selection<SVGGElement, {}, BaseType, {}>;

  /**
   * 辅助线绘制层
   */
  public helperLayout: Selection<SVGGElement, {}, BaseType, {}>;

  /**
   * 结构化数据
   */
  public nestedData: NestedArray<
    { [key: string]: number | string | null },
    string
  > = [];

  /**
   * 当高亮某数据系列时需要暂存原始值
   */
  private savedNestedData: NestedArray<
    { [key: string]: number | string | null },
    string
  > = [];

  /**
   * 禁用的数据系列名
   */
  private disabledKeys: string[] = [];

  public constructor(ctx: Context) {
    this.ctx = ctx;
    this.xAxis = this.ctx.plot.selection
      .append("g")
      .classed("x", true)
      .classed("axis", true);
    this.yAxis = this.ctx.plot.selection
      .append("g")
      .classed("y", true)
      .classed("axis", true);

    this.helperLayout = this.ctx.plot.selection
      .append("g")
      .attr("class", "helper-layout");

    this.ctx.addListener("plot.entered", this.onEnter.bind(this));
    this.ctx.addListener("plot.moved", this.onMoved.bind(this));
    this.ctx.addListener("plot.left", this.onLeft.bind(this));
    this.ctx.addListener("legend.clicked", this.onLegendClick.bind(this));
  }

  /**
   * 设置数据映射
   * @param x X 轴映射字段
   * @param y Y 轴映射字段
   */
  public setPosition(x: string, y: string) {
    this.xKey = x;
    this.yKey = y;
  }

  /**
   * 设置数据系列映射
   * @param serieKey 数据系列字段
   */
  public setSerie(serieKey: string) {
    this.serieKey = serieKey;
  }

  /**
   * 设置 X 轴比例尺类型
   * @param type 比例尺类型
   */
  public setXScaleType(type: this["XScaleType"]) {
    this.XScaleType = type;
  }

  public update() {
    this.nestedData = nest()
      .key(d => d[this.serieKey])
      .entries(this.ctx.dataSource);
    const series = [];
    for (const { key } of this.nestedData) {
      series.push(key);
    }

    // 设置每个系列的颜色
    const { color } = this.ctx.theme;
    const colorRange: string[] = typeof color === "function" ? [] : color;
    const colorScale = scaleOrdinal()
      .domain(series)
      .range(colorRange);
    for (const [i, serie] of this.nestedData.entries()) {
      const { key } = serie;
      serie.value =
        typeof color === "function"
          ? (color(key, i, this.nestedData.length - 1 === i) as string)
          : (colorScale(key) as string);
    }

    this.savedNestedData = this.nestedData;
    this.draw();
  }

  /**
   * 绘制坐标系
   */
  public draw() {
    this.updateScale();
    this.updateAxes();
    this.ctx.emit("coordinate-updated", this.savedNestedData, this.yKey);
  }

  /**
   * 更新数据比例尺
   */
  private updateScale() {
    const { domain } = this.ctx.scale[this.yKey] || { domain: null };
    const domains = calculateDomain(this.nestedData, this.xKey, this.yKey);
    const { xDomain, seriesDomain } = domains;
    const yDomain = domain || domains.yDomain;

    if (this.XScaleType === "Point") {
      this.xScale = scalePoint().domain(xDomain);
    } else if (this.XScaleType === "Band") {
      this.xScale = [
        scaleBand()
          .domain(xDomain)
          .paddingInner(0.1),
        scaleBand()
          .domain(seriesDomain)
          .paddingInner(0.05),
      ];
    }
    this.yScale = scaleLinear().domain(yDomain);
  }

  /**
   * 更新坐标轴
   */
  private updateAxes() {
    const labelWidth = this.drawYAxis();
    if (this.XScaleType === "Point") {
      this.drawXAxisWithPointScale(labelWidth);
    } else if (this.XScaleType === "Band") {
      this.drawXAxisWithBandScale(labelWidth);
    }
    this.style();
  }

  /**
   * 绘制 PointScale 类型的 X 坐标轴
   * @param offset Y 轴 Label 的宽度
   */
  private drawXAxisWithPointScale(offset = 0) {
    const { width, height } = this.ctx.plot;
    const { enable, formatter } = this.ctx.axis.xAxes;
    const scale = (this.xScale as ScalePoint<string>).range([offset, width]);

    if (enable === false) return;

    this.xAxis.attr("transform", `translate(0,${height})`).call(
      axisBottom(scale)
        .tickSizeOuter(0)
        .tickFormat((domainValue, index) => {
          if (typeof formatter === "function") {
            return formatter(domainValue, index);
          }
          return domainValue;
        })
    );
  }

  /**
   * 绘制 BandScale 类型的 X 坐标轴
   * @param offset Y 轴 Label 的宽度
   */
  private drawXAxisWithBandScale(offset = 0) {
    const { width, height } = this.ctx.plot;
    const { enable, formatter } = this.ctx.axis.xAxes;
    const [axisScale, serieScale] = this.xScale;
    axisScale.range([offset, width]);
    serieScale.range([0, (axisScale as ScaleBand<string>).bandwidth()]);

    if (enable === false) return;

    this.xAxis.attr("transform", `translate(0,${height})`).call(
      axisBottom(axisScale as ScaleBand<string>)
        .tickSizeOuter(0)
        .tickFormat((domainValue: string, index) => {
          if (typeof formatter === "function") {
            return formatter(domainValue, index);
          }
          return domainValue;
        })
    );
  }

  private drawYAxis() {
    const { height, width } = this.ctx.plot;

    const { enable, formatter } = this.ctx.axis.yAxes;
    const ticks = height / 20 > 5 ? 5 : Math.round(height / 20);
    const scale = axisLeft(this.yScale.range([height, 0]))
      .tickSize(-width)
      .ticks(ticks)
      .tickFormat((value, index) => {
        const domainValue = value === 0 ? "0" : format(",.2r")(Number(value));
        if (typeof formatter === "function") {
          return formatter(domainValue, index);
        }
        return String(domainValue);
      });

    if (enable === false) return 0;

    this.yAxis.call(scale);
    return getLabelMaxWidth(this.yAxis.selectAll("text").nodes()) + 10;
  }

  /**
   * 统一设置样式
   */
  private style() {
    this.xAxis.select(".domain").remove();
    this.xAxis.selectAll(".tick line").attr("stroke", "#CECECE");
    this.xAxis
      .selectAll(".tick text")
      .attr("fill", "#B0B0B0")
      .attr("font", "14px");

    if (this.XScaleType === "Point") {
      const firstXTick = this.xAxis.select(".tick:first-child text");
      firstXTick.attr("x", getLabelMaxWidth([firstXTick.node()]) / 2);

      const lastXTick = this.xAxis.select(".tick:last-child text");
      lastXTick.attr("x", -getLabelMaxWidth([lastXTick.node()]) / 2);
    }

    this.yAxis.select(".domain").remove();
    this.yAxis
      .selectAll(".tick text")
      .attr("fill", "#B0B0B0")
      .attr("font", "14px")
      .attr("x", 4)
      .attr("text-anchor", "start");

    if (this.ctx.axis.xAxes.enable) {
      this.yAxis.selectAll(".tick line").attr("stroke", "#ECECEC");
      this.yAxis.selectAll(".tick:first-child line").attr("stroke", "#CECECE");
      this.yAxis.selectAll(".tick text").attr("dy", 12);
      this.yAxis.select(".tick:first-child text").remove();

      const nodes = this.xAxis.selectAll(".tick").nodes();
      const scale = this.XScaleType === "Point" ? this.xScale : this.xScale[0];
      const { width } = this.ctx.plot;
      // 自动计算 ticks 个数
      const maxLabelWidth = getLabelMaxWidth(nodes) + 20; // 另外新增 20px 的 padding
      const maxCount = Math.floor(width / (2 * maxLabelWidth));

      for (const [i, node] of nodes.entries()) {
        const len = nodes.length;
        const isLast = i === len - 1;
        if (i !== 0 && !isLast) {
          const gapWidth = Math.floor(len / maxCount);
          const position = scale(scale.domain()[i]);
          if (width - position < maxLabelWidth || i % gapWidth) {
            select(node).remove();
          }
        }
      }
    } else {
      this.yAxis.selectAll(".tick line").remove();
    }
  }

  private onEnter() {
    if (this.ctx.tooltip.enable === false) return;
    this.helperLayout.select(".mouse-line").style("opacity", "1");
  }

  private onLeft() {
    if (this.ctx.tooltip.enable === false) return;
    this.helperLayout.select(".mouse-line").style("opacity", "0");
    this.ctx.emit("coordinate.helper.hide");
  }

  private onMoved(x: number, y: number) {
    if (this.ctx.tooltip.enable === false) return;
    const [{ values }] = this.nestedData;
    let domain: string[];
    let index: number;
    let xPos: number;
    if (this.XScaleType === "Point") {
      const scale = this.xScale as ScalePoint<string>;
      const range = scale.range();
      const rangePoints = d3Range(range[0], range[1], scale.step());
      domain = scale.domain();
      index = bisectRight(rangePoints, x);
      xPos = scale(values[index][this.xKey]);
    } else if (this.XScaleType === "Band") {
      const [axisScale] = this.xScale;
      domain = axisScale.domain();
      const offset = axisScale(domain[0]);
      index = Math.floor((x - offset) / axisScale.step());
      xPos = axisScale(domain[index]);
    }

    if (index < 0 || index > domain.length - 1) return;

    const alias = this.ctx.scale[this.yKey] && this.ctx.scale[this.yKey].alias;
    const metaData = [];
    for (const { value: color, values, key } of this.nestedData) {
      const label = alias || (key === "undefined" ? this.yKey : key);
      let value = values[index][this.yKey];
      value = typeof value === "number" ? format(",")(value) : "-";
      metaData.push({
        title: domain[index],
        label,
        value,
        color,
        row: values[index],
      });
    }

    this.ctx.emit("coordinate.helper.show", {
      x, // x 坐标
      y, // y 坐标
      xPos, // 数据 x 映射坐标
      metaData, // 提示框数据
      index, // 索引值
      type: this.XScaleType, // 比例尺类型
    });
  }

  /**
   * 图例点击事件
   * @param legendData 被点击的图例信息
   * @param disabled 改图例元素是否是禁用状态
   */
  private onLegendClick(legendData: LegendData, disabled: boolean) {
    const { key } = legendData;
    if (disabled) {
      this.disabledKeys.push(key);
    } else {
      this.disabledKeys = this.disabledKeys.filter(d => d !== key);
    }
    const filterData = [];
    for (const serie of this.savedNestedData) {
      if (!this.disabledKeys.includes(serie.key)) {
        filterData.push(serie);
      }
    }
    this.nestedData = filterData;
    this.draw();
  }
}

function calculateDomain(
  nestData: NestedArray<{ [key: string]: number | string | null }, string>,
  xKey: string,
  yKey: string
) {
  const xDomain: string[] = [];
  const yDomain = [0, 0];
  const seriesDomain = [];
  for (const { values, key } of nestData) {
    seriesDomain.push(key);
    for (const [index, row] of values.entries()) {
      const x = row[xKey];
      const y = row[yKey];
      if (!xDomain.includes(x)) {
        xDomain.splice(index, 0, x);
      }
      if (y > yDomain[1]) {
        yDomain[1] = y;
      }
    }
  }
  yDomain[1] *= 1.3;
  return { xDomain, yDomain, seriesDomain };
}
