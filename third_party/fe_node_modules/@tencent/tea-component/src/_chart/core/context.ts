import EventEmitter from "eventemitter3";
import { Selection, select } from "d3";
import { Theme, Legend, Axis, Tooltip } from "../type";
import { Tea } from "../theme";
import { Combine } from "../../_type";

export interface Scale {
  [key: string]: {
    alias?: string;
    domain?: [number, number];
  };
}

export interface DataRow {
  [key: string]: string | number;
}

export class Context extends EventEmitter {
  /**
   * 主题
   */
  public theme: Theme = Tea();

  /**
   * 数据表
   */
  public dataSource: {
    [key: string]: string | number;
  }[] = [];

  /**
   * 容器
   */
  public root: HTMLElement;

  /**
   * 视图区
   */
  public view: Selection<SVGElement, {}, HTMLElement, {}>;

  /**
   * 绘图区
   */
  public plot: {
    selection?: Selection<SVGGElement, {}, HTMLElement, {}>;
    height?: number;
    width?: number;
    padding?: Theme["padding"];
  } = {};

  /**
   * 图例区
   */
  public legend: Combine<
    Legend,
    {
      selection?: Selection<SVGGElement, {}, HTMLElement, {}>;
    }
  > = {
    enable: true,
  };

  /**
   * 自定义轴操作
   */
  public axis: {
    xAxes?: Axis;
    yAxes?: Axis;
  } = {
    xAxes: { enable: true },
    yAxes: { enable: true },
  };

  /**
   * 比例尺，比例尺用以限定值域范围等
   */
  public scale: Scale = {};

  /**
   * 提示框
   */
  public tooltip: Tooltip = {
    enable: true,
  };

  public constructor(root: HTMLElement, cfg: Theme = {}) {
    super();
    if (typeof cfg === "object") {
      for (const key in cfg) {
        if (Object.prototype.hasOwnProperty.call(cfg, key)) {
          this.theme[key] = cfg[key];
        }
      }
    }

    this.root = root;
    this.view = select(this.root).append("svg");
    // 创建绘图区
    this.plot.selection = this.view
      .append("g")
      .classed("plot", true)
      .style("position", "relative");
    this.plot.padding = this.theme.padding;
    this.setSize();
  }

  public setSize() {
    const { width, height } = window.getComputedStyle(this.root);
    const {
      padding: { left, right, top, bottom },
    } = this.plot;
    const plotWidthOffset = left + right;
    const plotHeightOffset = this.legend.enable
      ? top + bottom + this.theme.legend.height
      : top + bottom;
    this.view.attr(
      "viewBox",
      `0, 0, ${parseInt(width, 10)}, ${parseInt(height, 10)}`
    );
    this.plot.width = parseInt(width, 10) - plotWidthOffset;
    this.plot.height = parseInt(height, 10) - plotHeightOffset - 5;
    this.plot.selection.attr("transform", `translate(${left},${top})`);
  }

  public setScale(scale: Scale) {
    this.scale = scale;
  }

  public setSource(dataSource: DataRow[]) {
    this.dataSource = dataSource;
  }

  public setTooltip(cfg: Tooltip) {
    for (const key in cfg) {
      if (Object.prototype.hasOwnProperty.call(cfg, key)) {
        this.tooltip[key] = cfg[key];
      }
    }
  }

  public setAxis(axis: this["axis"]) {
    this.axis = axis;
  }

  public setLegend(cfg: Legend) {
    for (const key in cfg) {
      if (Object.prototype.hasOwnProperty.call(cfg, key)) {
        this.legend[key] = cfg[key];
      }
    }
  }

  public getColor(key: string, index: number, isLast?: boolean) {
    if (typeof this.theme.color === "function") {
      return this.theme.color(key, index, isLast);
    }
    const len = this.theme.color.length;
    return this.theme.color[index % len];
  }
}
