"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var d3_1 = require("d3");
var svg_helper_1 = require("../lib/svg-helper");
var RectCoordinate = /** @class */ (function () {
    function RectCoordinate(ctx) {
        /**
         * X 轴比例尺类型
         */
        this.XScaleType = "Point";
        /**
         * 结构化数据
         */
        this.nestedData = [];
        /**
         * 当高亮某数据系列时需要暂存原始值
         */
        this.savedNestedData = [];
        /**
         * 禁用的数据系列名
         */
        this.disabledKeys = [];
        this.ctx = ctx;
        this.xAxis = this.ctx.plot.selection
            .append("g")
            .classed("x", true)
            .classed("axis", true);
        this.yAxis = this.ctx.plot.selection
            .append("g")
            .classed("y", true)
            .classed("axis", true);
        this.helperLayout = this.ctx.plot.selection
            .append("g")
            .attr("class", "helper-layout");
        this.ctx.addListener("plot.entered", this.onEnter.bind(this));
        this.ctx.addListener("plot.moved", this.onMoved.bind(this));
        this.ctx.addListener("plot.left", this.onLeft.bind(this));
        this.ctx.addListener("legend.clicked", this.onLegendClick.bind(this));
    }
    /**
     * 设置数据映射
     * @param x X 轴映射字段
     * @param y Y 轴映射字段
     */
    RectCoordinate.prototype.setPosition = function (x, y) {
        this.xKey = x;
        this.yKey = y;
    };
    /**
     * 设置数据系列映射
     * @param serieKey 数据系列字段
     */
    RectCoordinate.prototype.setSerie = function (serieKey) {
        this.serieKey = serieKey;
    };
    /**
     * 设置 X 轴比例尺类型
     * @param type 比例尺类型
     */
    RectCoordinate.prototype.setXScaleType = function (type) {
        this.XScaleType = type;
    };
    RectCoordinate.prototype.update = function () {
        var _this = this;
        var e_1, _a, e_2, _b;
        this.nestedData = d3_1.nest()
            .key(function (d) { return d[_this.serieKey]; })
            .entries(this.ctx.dataSource);
        var series = [];
        try {
            for (var _c = tslib_1.__values(this.nestedData), _d = _c.next(); !_d.done; _d = _c.next()) {
                var key = _d.value.key;
                series.push(key);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // 设置每个系列的颜色
        var color = this.ctx.theme.color;
        var colorRange = typeof color === "function" ? [] : color;
        var colorScale = d3_1.scaleOrdinal()
            .domain(series)
            .range(colorRange);
        try {
            for (var _e = tslib_1.__values(this.nestedData.entries()), _f = _e.next(); !_f.done; _f = _e.next()) {
                var _g = tslib_1.__read(_f.value, 2), i = _g[0], serie = _g[1];
                var key = serie.key;
                serie.value =
                    typeof color === "function"
                        ? color(key, i, this.nestedData.length - 1 === i)
                        : colorScale(key);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
        this.savedNestedData = this.nestedData;
        this.draw();
    };
    /**
     * 绘制坐标系
     */
    RectCoordinate.prototype.draw = function () {
        this.updateScale();
        this.updateAxes();
        this.ctx.emit("coordinate-updated", this.savedNestedData, this.yKey);
    };
    /**
     * 更新数据比例尺
     */
    RectCoordinate.prototype.updateScale = function () {
        var domain = (this.ctx.scale[this.yKey] || { domain: null }).domain;
        var domains = calculateDomain(this.nestedData, this.xKey, this.yKey);
        var xDomain = domains.xDomain, seriesDomain = domains.seriesDomain;
        var yDomain = domain || domains.yDomain;
        if (this.XScaleType === "Point") {
            this.xScale = d3_1.scalePoint().domain(xDomain);
        }
        else if (this.XScaleType === "Band") {
            this.xScale = [
                d3_1.scaleBand()
                    .domain(xDomain)
                    .paddingInner(0.1),
                d3_1.scaleBand()
                    .domain(seriesDomain)
                    .paddingInner(0.05),
            ];
        }
        this.yScale = d3_1.scaleLinear().domain(yDomain);
    };
    /**
     * 更新坐标轴
     */
    RectCoordinate.prototype.updateAxes = function () {
        var labelWidth = this.drawYAxis();
        if (this.XScaleType === "Point") {
            this.drawXAxisWithPointScale(labelWidth);
        }
        else if (this.XScaleType === "Band") {
            this.drawXAxisWithBandScale(labelWidth);
        }
        this.style();
    };
    /**
     * 绘制 PointScale 类型的 X 坐标轴
     * @param offset Y 轴 Label 的宽度
     */
    RectCoordinate.prototype.drawXAxisWithPointScale = function (offset) {
        if (offset === void 0) { offset = 0; }
        var _a = this.ctx.plot, width = _a.width, height = _a.height;
        var _b = this.ctx.axis.xAxes, enable = _b.enable, formatter = _b.formatter;
        var scale = this.xScale.range([offset, width]);
        if (enable === false)
            return;
        this.xAxis.attr("transform", "translate(0," + height + ")").call(d3_1.axisBottom(scale)
            .tickSizeOuter(0)
            .tickFormat(function (domainValue, index) {
            if (typeof formatter === "function") {
                return formatter(domainValue, index);
            }
            return domainValue;
        }));
    };
    /**
     * 绘制 BandScale 类型的 X 坐标轴
     * @param offset Y 轴 Label 的宽度
     */
    RectCoordinate.prototype.drawXAxisWithBandScale = function (offset) {
        if (offset === void 0) { offset = 0; }
        var _a = this.ctx.plot, width = _a.width, height = _a.height;
        var _b = this.ctx.axis.xAxes, enable = _b.enable, formatter = _b.formatter;
        var _c = tslib_1.__read(this.xScale, 2), axisScale = _c[0], serieScale = _c[1];
        axisScale.range([offset, width]);
        serieScale.range([0, axisScale.bandwidth()]);
        if (enable === false)
            return;
        this.xAxis.attr("transform", "translate(0," + height + ")").call(d3_1.axisBottom(axisScale)
            .tickSizeOuter(0)
            .tickFormat(function (domainValue, index) {
            if (typeof formatter === "function") {
                return formatter(domainValue, index);
            }
            return domainValue;
        }));
    };
    RectCoordinate.prototype.drawYAxis = function () {
        var _a = this.ctx.plot, height = _a.height, width = _a.width;
        var _b = this.ctx.axis.yAxes, enable = _b.enable, formatter = _b.formatter;
        var ticks = height / 20 > 5 ? 5 : Math.round(height / 20);
        var scale = d3_1.axisLeft(this.yScale.range([height, 0]))
            .tickSize(-width)
            .ticks(ticks)
            .tickFormat(function (value, index) {
            var domainValue = value === 0 ? "0" : d3_1.format(",.2r")(Number(value));
            if (typeof formatter === "function") {
                return formatter(domainValue, index);
            }
            return String(domainValue);
        });
        if (enable === false)
            return 0;
        this.yAxis.call(scale);
        return svg_helper_1.getLabelMaxWidth(this.yAxis.selectAll("text").nodes()) + 10;
    };
    /**
     * 统一设置样式
     */
    RectCoordinate.prototype.style = function () {
        var e_3, _a;
        this.xAxis.select(".domain").remove();
        this.xAxis.selectAll(".tick line").attr("stroke", "#CECECE");
        this.xAxis
            .selectAll(".tick text")
            .attr("fill", "#B0B0B0")
            .attr("font", "14px");
        if (this.XScaleType === "Point") {
            var firstXTick = this.xAxis.select(".tick:first-child text");
            firstXTick.attr("x", svg_helper_1.getLabelMaxWidth([firstXTick.node()]) / 2);
            var lastXTick = this.xAxis.select(".tick:last-child text");
            lastXTick.attr("x", -svg_helper_1.getLabelMaxWidth([lastXTick.node()]) / 2);
        }
        this.yAxis.select(".domain").remove();
        this.yAxis
            .selectAll(".tick text")
            .attr("fill", "#B0B0B0")
            .attr("font", "14px")
            .attr("x", 4)
            .attr("text-anchor", "start");
        if (this.ctx.axis.xAxes.enable) {
            this.yAxis.selectAll(".tick line").attr("stroke", "#ECECEC");
            this.yAxis.selectAll(".tick:first-child line").attr("stroke", "#CECECE");
            this.yAxis.selectAll(".tick text").attr("dy", 12);
            this.yAxis.select(".tick:first-child text").remove();
            var nodes = this.xAxis.selectAll(".tick").nodes();
            var scale = this.XScaleType === "Point" ? this.xScale : this.xScale[0];
            var width = this.ctx.plot.width;
            // 自动计算 ticks 个数
            var maxLabelWidth = svg_helper_1.getLabelMaxWidth(nodes) + 20; // 另外新增 20px 的 padding
            var maxCount = Math.floor(width / (2 * maxLabelWidth));
            try {
                for (var _b = tslib_1.__values(nodes.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = tslib_1.__read(_c.value, 2), i = _d[0], node = _d[1];
                    var len = nodes.length;
                    var isLast = i === len - 1;
                    if (i !== 0 && !isLast) {
                        var gapWidth = Math.floor(len / maxCount);
                        var position = scale(scale.domain()[i]);
                        if (width - position < maxLabelWidth || i % gapWidth) {
                            d3_1.select(node).remove();
                        }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        else {
            this.yAxis.selectAll(".tick line").remove();
        }
    };
    RectCoordinate.prototype.onEnter = function () {
        if (this.ctx.tooltip.enable === false)
            return;
        this.helperLayout.select(".mouse-line").style("opacity", "1");
    };
    RectCoordinate.prototype.onLeft = function () {
        if (this.ctx.tooltip.enable === false)
            return;
        this.helperLayout.select(".mouse-line").style("opacity", "0");
        this.ctx.emit("coordinate.helper.hide");
    };
    RectCoordinate.prototype.onMoved = function (x, y) {
        var e_4, _a;
        if (this.ctx.tooltip.enable === false)
            return;
        var _b = tslib_1.__read(this.nestedData, 1), values = _b[0].values;
        var domain;
        var index;
        var xPos;
        if (this.XScaleType === "Point") {
            var scale = this.xScale;
            var range = scale.range();
            var rangePoints = d3_1.range(range[0], range[1], scale.step());
            domain = scale.domain();
            index = d3_1.bisectRight(rangePoints, x);
            xPos = scale(values[index][this.xKey]);
        }
        else if (this.XScaleType === "Band") {
            var _c = tslib_1.__read(this.xScale, 1), axisScale = _c[0];
            domain = axisScale.domain();
            var offset = axisScale(domain[0]);
            index = Math.floor((x - offset) / axisScale.step());
            xPos = axisScale(domain[index]);
        }
        if (index < 0 || index > domain.length - 1)
            return;
        var alias = this.ctx.scale[this.yKey] && this.ctx.scale[this.yKey].alias;
        var metaData = [];
        try {
            for (var _d = tslib_1.__values(this.nestedData), _e = _d.next(); !_e.done; _e = _d.next()) {
                var _f = _e.value, color = _f.value, values_1 = _f.values, key = _f.key;
                var label = alias || (key === "undefined" ? this.yKey : key);
                var value = values_1[index][this.yKey];
                value = typeof value === "number" ? d3_1.format(",")(value) : "-";
                metaData.push({
                    title: domain[index],
                    label: label,
                    value: value,
                    color: color,
                    row: values_1[index],
                });
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_4) throw e_4.error; }
        }
        this.ctx.emit("coordinate.helper.show", {
            x: x,
            y: y,
            xPos: xPos,
            metaData: metaData,
            index: index,
            type: this.XScaleType,
        });
    };
    /**
     * 图例点击事件
     * @param legendData 被点击的图例信息
     * @param disabled 改图例元素是否是禁用状态
     */
    RectCoordinate.prototype.onLegendClick = function (legendData, disabled) {
        var e_5, _a;
        var key = legendData.key;
        if (disabled) {
            this.disabledKeys.push(key);
        }
        else {
            this.disabledKeys = this.disabledKeys.filter(function (d) { return d !== key; });
        }
        var filterData = [];
        try {
            for (var _b = tslib_1.__values(this.savedNestedData), _c = _b.next(); !_c.done; _c = _b.next()) {
                var serie = _c.value;
                if (!this.disabledKeys.includes(serie.key)) {
                    filterData.push(serie);
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
        this.nestedData = filterData;
        this.draw();
    };
    return RectCoordinate;
}());
exports.RectCoordinate = RectCoordinate;
function calculateDomain(nestData, xKey, yKey) {
    var e_6, _a, e_7, _b;
    var xDomain = [];
    var yDomain = [0, 0];
    var seriesDomain = [];
    try {
        for (var nestData_1 = tslib_1.__values(nestData), nestData_1_1 = nestData_1.next(); !nestData_1_1.done; nestData_1_1 = nestData_1.next()) {
            var _c = nestData_1_1.value, values = _c.values, key = _c.key;
            seriesDomain.push(key);
            try {
                for (var _d = tslib_1.__values(values.entries()), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var _f = tslib_1.__read(_e.value, 2), index = _f[0], row = _f[1];
                    var x = row[xKey];
                    var y = row[yKey];
                    if (!xDomain.includes(x)) {
                        xDomain.splice(index, 0, x);
                    }
                    if (y > yDomain[1]) {
                        yDomain[1] = y;
                    }
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                }
                finally { if (e_7) throw e_7.error; }
            }
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (nestData_1_1 && !nestData_1_1.done && (_a = nestData_1.return)) _a.call(nestData_1);
        }
        finally { if (e_6) throw e_6.error; }
    }
    yDomain[1] *= 1.3;
    return { xDomain: xDomain, yDomain: yDomain, seriesDomain: seriesDomain };
}
//# sourceMappingURL=rect.js.map