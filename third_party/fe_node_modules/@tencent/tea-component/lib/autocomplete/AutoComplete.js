"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importStar(require("react"));
var popover_1 = require("../popover");
var dropdown_1 = require("../dropdown");
var list_1 = require("../list");
var form_1 = require("../form");
var text_1 = require("../text");
var tips_1 = require("../tips");
function highlight(text, keyword) {
    if (typeof text !== "string") {
        return text;
    }
    return text.split(keyword).map(function (text, index) {
        var key = text + "-" + index;
        if (index >= 1) {
            return (react_1.default.createElement(react_1.Fragment, { key: key },
                react_1.default.createElement(text_1.Text, { theme: index === 1 ? "primary" : "text" }, keyword),
                text));
        }
        return react_1.default.createElement(text_1.Text, { key: key }, text);
    });
}
function AutoComplete(props) {
    var _a = form_1.useDefaultValue(props), className = _a.className, _b = _a.style, style = _b === void 0 ? {} : _b, value = _a.value, onChange = _a.onChange, children = _a.children, _c = _a.options, options = _c === void 0 ? [] : _c, _d = _a.groups, groups = _d === void 0 ? {} : _d, _e = _a.tips, tips = _e === void 0 ? "" : _e, keyword = _a.keyword, onScrollBottom = _a.onScrollBottom, _f = _a.closeOnScroll, closeOnScroll = _f === void 0 ? true : _f;
    var timerRef = react_1.useRef(null);
    var inputRef = react_1.useRef(null);
    var _g = tslib_1.__read(react_1.useState(false), 2), isOpened = _g[0], setIsOpened = _g[1];
    var _h = tslib_1.__read(react_1.useState(undefined), 2), dropdownWidth = _h[0], setDropdownWidth = _h[1];
    react_1.useEffect(function () { return function () { return clearTimeout(timerRef.current); }; }, []);
    var close = function () { return setIsOpened(false); };
    var hasGroup = !!options.find(function (opt) { return !!opt.groupKey; });
    return (react_1.default.createElement(popover_1.Popover, { animationScaleFrom: 1, transitionTimeout: { enter: 0, exit: 100 }, trigger: AutoCompleteTrigger, placement: "bottom-start", visible: isOpened, onVisibleChange: setIsOpened, placementOffset: 5, closeOnScroll: closeOnScroll, overlay: react_1.default.createElement(dropdown_1.DropdownBox, { className: className, style: tslib_1.__assign({ width: dropdownWidth }, style) }, Array.isArray(options) && options.length > 0 ? (react_1.default.createElement(list_1.List, { type: hasGroup ? "option-group" : "option", onScrollBottom: onScrollBottom }, options.map(function (_a, index) {
            var optValue = _a.value, text = _a.text, disabled = _a.disabled, tooltip = _a.tooltip, groupKey = _a.groupKey;
            var item = (react_1.default.createElement(list_1.List.Item, { key: optValue, current: optValue === value, disabled: disabled, tooltip: tooltip, onClick: function (event) {
                    event.stopPropagation();
                    inputRef.current.focus();
                    onChange(optValue, { event: event });
                    timerRef.current = setTimeout(close, 1);
                } }, highlight(text || optValue, keyword)));
            if (groupKey &&
                (index === 0 || groupKey !== options[index - 1].groupKey)) {
                return (react_1.default.createElement(react_1.Fragment, { key: optValue },
                    react_1.default.createElement(list_1.List.GroupLabel, null, groups[groupKey]),
                    item));
            }
            return item;
        }))) : (!!tips && (react_1.default.createElement(list_1.List, { type: "option" },
            react_1.default.createElement(list_1.List.StatusTip, null, typeof tips === "string" ? (react_1.default.createElement(tips_1.EmptyTip, { emptyText: tips })) : (tips)))))) }, children(function (dom) {
        inputRef.current = dom;
        if (dom) {
            setDropdownWidth(dom.offsetWidth);
        }
    }, { close: function () { return setIsOpened(false); } })));
}
exports.AutoComplete = AutoComplete;
function AutoCompleteTrigger(_a) {
    var setVisible = _a.setVisible, _b = _a.openDelay, openDelay = _b === void 0 ? 0 : _b, _c = _a.closeDelay, closeDelay = _c === void 0 ? 0 : _c, render = _a.render;
    var commonProps = {
        onFocus: function () { return setVisible(true, openDelay); },
        onChange: function () { return setVisible(true, openDelay); },
        onClick: function () { return setVisible(true, openDelay); },
        onBlur: function () { return setVisible(false, closeDelay); },
    };
    return render({
        overlayProps: tslib_1.__assign({}, commonProps, { tabIndex: 1000 }),
        childrenProps: commonProps,
    });
}
exports.AutoCompleteTrigger = AutoCompleteTrigger;
AutoComplete.defaultLabelAlign = "middle";
//# sourceMappingURL=AutoComplete.js.map