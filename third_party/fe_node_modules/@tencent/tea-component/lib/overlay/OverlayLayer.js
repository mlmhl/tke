"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importDefault(require("react"));
var react_dom_1 = tslib_1.__importDefault(require("react-dom"));
var classnames_1 = tslib_1.__importDefault(require("classnames"));
var react_popper_1 = require("react-popper");
var get_overlay_root_1 = require("../_util/get-overlay-root");
var merge_style_1 = require("../_util/merge-style");
var call_both_1 = require("../_util/call-both");
var transition_1 = require("../transition");
var use_visible_transition_1 = require("../_util/use-visible-transition");
var inject_value_1 = require("../_util/inject-value");
var scaleOriginForPlacement = (function (originMap) { return function (placement) {
    var basePlacement = placement.split("-").shift();
    return originMap[basePlacement];
}; })({
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left",
});
var overlayRoot = get_overlay_root_1.getOverlayRoot();
/**
 * 为定位元素创建一个覆盖层
 *
 * @example
 *
  ```js
  const [visible, setVisible] = useState(false);
  const open = () => setVisible(true);
  const close = () => setVisible(false);
  <Overlay
    visible={visible}
    content={<div>我是浮层内容，<a onClick={close}>关闭</a></div>}
    children={ref => <a ref={ref} onClick={open}>点击弹出浮层</a>}
  />
  ```
 */
function OverlayLayer(_a) {
    var content = _a.content, overlayRef = _a.overlayRef, _b = _a.overlayProps, overlayProps = _b === void 0 ? {} : _b, _c = _a.placement, placement = _c === void 0 ? "bottom-start" : _c, visible = _a.visible, _d = _a.placementOffset, placementOffset = _d === void 0 ? 5 : _d, _e = _a.transitionTimeout, transitionTimeout = _e === void 0 ? { enter: 50, exit: 300 } : _e, updateOnDimensionChange = _a.updateOnDimensionChange, referenceElement = _a.referenceElement, _f = _a.animationScaleFrom, animationScaleFrom = _f === void 0 ? 0.93 : _f;
    // visible 启动时，才开始渲染内容，进行动画
    var _g = use_visible_transition_1.useVisibleTransition(visible), shouldContentRender = _g.shouldContentRender, shouldContentEnter = _g.shouldContentEnter, onContentExit = _g.onContentExit;
    if (!shouldContentRender) {
        return null;
    }
    // 渲染定位组件
    return react_dom_1.default.createPortal(react_1.default.createElement(react_popper_1.Popper, { referenceElement: referenceElement, placement: placement, modifiers: {
            offset: {
                enabled: true,
                offset: "0," + placementOffset,
            },
            preventOverflow: {
                boundariesElement: "viewport",
            },
            computeStyle: {
                // 使用 translate3d() 在 Windows 下有 DPI 缩放时会导致模糊
                // 只有在 resize 和 scroll 的时候才会有更新的需求，暂时关闭 GPU 加速
                gpuAcceleration: false,
            },
        }, eventsEnabled: updateOnDimensionChange, positionFixed: true }, function (popper) {
        var overlayContent = inject_value_1.injectValue(content)(tslib_1.__assign({}, popper, { visible: visible }));
        return (react_1.default.createElement(transition_1.ScaleTransition, { from: animationScaleFrom, origin: scaleOriginForPlacement(placement), timeout: transitionTimeout, in: shouldContentEnter, onEnter: function () { return popper.scheduleUpdate(); }, onExited: onContentExit },
            react_1.default.createElement("div", tslib_1.__assign({}, overlayProps, { 
                // 覆盖层类名，样式表中包含 z-index 来确定覆盖层的层级
                className: classnames_1.default("tea-overlay", overlayProps.className), 
                // ref 同时提供给 popper 和 contentRef
                ref: call_both_1.callBoth(popper.ref, overlayRef), 
                // popper.style 为 overlay 浮层提供定位
                // contentStyle 提供给用户改写的可能
                style: merge_style_1.mergeStyle(popper.style, { willChange: null }, overlayProps.style), "data-placement": popper.placement || placement }), react_1.default.isValidElement(overlayContent) ? (overlayContent) : (react_1.default.createElement("span", null, overlayContent)))));
    }), overlayRoot);
}
exports.OverlayLayer = OverlayLayer;
//# sourceMappingURL=OverlayLayer.js.map