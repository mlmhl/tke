import React, { SyntheticEvent, ReactNode } from "react";
import classNames from "classnames";
import { ControlledProps, ChangeContext } from "../../form/controlled";
import { StyledProps } from "../../_type";
import { Text } from "../../text";
import { Icon } from "../../icon";
import { TableAddon } from "../TableProps";

/**
 * `sortable` 插件用于支持表格的排序操作。
```jsx
import { sortable } from '@tea/component/table/addons/sortable';
function Example() {
  return <Table addons={[sortable(options)]} />;
}
```
 */
export interface SortableOptions
  extends ControlledProps<SortBy[], SyntheticEvent, SortableChangeContext> {
  /**
   * 不支持非受控模式
   */
  defaultValue?: never;

  /**
   * 指定哪些列支持排序，可传入键值，或者详细配置
   */
  columns: (string | SortableColumn)[];
}

export interface SortableColumn {
  /**
   * 要支持排序的列的键值
   */
  key: string;

  /**
   * 当列从未排序进入排序状态时，优先使用的排序状态
   */
  prefer: SortOrder;
}

export interface SortableChangeContext extends ChangeContext {
  /**
   * 当前引起变更的排序信息
   */
  sort: SortBy;
}

export type SortOrder = "asc" | "desc";

export interface SortBy {
  /**
   * 按照哪一列排序
   */
  by: string;

  /**
   * 升序/倒序
   */
  order: SortOrder;
}

export function sortable(options: SortableOptions): TableAddon {
  const sortablePrefer = new Map<string, SortOrder>(
    (options.columns || []).map(column =>
      typeof column === "string"
        ? ([column, "asc"] as [string, SortOrder])
        : ([column.key, column.prefer] as [string, SortOrder])
    )
  );
  const sortMap = new Map<string, SortOrder>(
    (options.value || []).map(
      sort => [sort.by, sort.order] as [string, SortOrder]
    )
  );

  return {
    onInjectColumn: renderColumn => (record, rowKey, recordIndex, column) => {
      const columnResult = renderColumn(record, rowKey, recordIndex, column);

      // recordIndex > -1 是记录行，我们只注入表头
      if (recordIndex > -1) {
        return columnResult;
      }

      // 不是可排序列，跳过
      if (!sortablePrefer.has(column.key)) {
        return columnResult;
      }

      // 获取原始渲染内容
      let { children } = columnResult;

      // 当前的排序状态：undefined | "asc" | "desc"
      const order = sortMap.get(column.key);

      // 切换排序状态
      const changeOrder = (event: React.MouseEvent) => {
        if (typeof options.onChange !== "function") {
          return;
        }
        let nextOrder: SortOrder = sortablePrefer.get(column.key);
        if (order === "asc") {
          nextOrder = "desc";
        }
        if (order === "desc") {
          nextOrder = "asc";
        }
        const sort: SortBy = {
          by: column.key,
          order: nextOrder,
        };
        // 删除旧排序规则，保证新的在前
        sortMap.delete(column.key);
        const value: SortBy[] = [sort].concat(
          Array.from(sortMap).map(([by, order]) => ({ by, order }))
        );
        options.onChange(value, { event, sort });
      };

      // 包装一个排序按钮
      children = (
        <SortButton order={order} onClick={changeOrder}>
          {children}
        </SortButton>
      );

      return { ...columnResult, children };
    },
  };
}

export interface SortButtonProps extends StyledProps {
  children?: ReactNode;
  order?: SortOrder;
  onClick?: (evt: React.MouseEvent<HTMLSpanElement>) => void;
}

export function SortButton({
  order,
  className,
  style,
  children,
  onClick,
}: SortButtonProps) {
  let iconType = "sort";
  if (order === "asc") {
    iconType = "sortup";
  }
  if (order === "desc") {
    iconType = "sortdown";
  }

  return (
    <span
      className={classNames(
        "tea-table__sortbtn",
        { "is-active": Boolean(order) },
        className
      )}
      style={style}
      onClick={onClick}
    >
      <Text overflow className="tea-table__headerop">
        {children}
      </Text>
      <Icon type={iconType} />
    </span>
  );
}

function comparer(sorts: SortBy[]) {
  return (a: any, b: any) => {
    for (const { by, order } of sorts) {
      const isAsc = a[by] < b[by];
      const isDesc = a[by] > b[by];
      if (isAsc || isDesc) {
        if (order === "asc") return isAsc ? -1 : 1;
        if (order === "desc") return isDesc ? -1 : 1;
      }
    }
    return 0;
  };
}

sortable.comparer = comparer as ((
  sorts: SortBy[]
) => (a: any, b: any) => number);
