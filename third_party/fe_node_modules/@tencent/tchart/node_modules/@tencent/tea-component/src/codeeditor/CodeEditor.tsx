import React, { useRef, useEffect, MutableRefObject, useState } from "react";
import classNames from "classnames";
import { useLast } from "../_util/use-last";
import { StyledProps } from "../_type";
import { mergeStyle } from "../_util/merge-style";

type BasicType = string | boolean | number | (string | boolean | number)[];
type ExtractBasic<T> = Extract<T, BasicType>;

type PickBasic<T> = {
  [key in keyof T]: T[key] extends { [key: string]: any }
    ? PickBasic<T[key]>
    : ExtractBasic<T[key]>
};

type IEditorConstructionOptions = import("monaco-editor").editor.IEditorConstructionOptions;

/**
 * `options` 详见： [IEditorConstructionOptions](https://microsoft.github.io/monaco-editor/api/interfaces/monaco.editor.ieditorconstructionoptions.html)
 */
export interface CodeEditorOptions
  extends PickBasic<IEditorConstructionOptions> {}

export interface CodeEditorProps extends StyledProps {
  /**
   * 编辑器配置，会合并下面的默认值：
```js
{ "language": "javascript" }
```
   * 该配置只有在初始渲染时传入有效，后续传入不再生效。
   * 支持的配置请参考： [IEditorConstructionOptions](https://microsoft.github.io/monaco-editor/api/interfaces/monaco.editor.ieditorconstructionoptions.html)
   *
   * > 注意：由于 `options` 经过 JSON 序列化给到 iframe，所以配置中传入函数的方式都会无效
   */
  options?: CodeEditorOptions;

  /**
   * 是否自动获得焦点
   * @default false
   */
  autoFocus?: boolean;

  /**
   * 加载时显示的文本
   */
  loadingPlaceholder?: React.ReactChild;

  /**
   * 发生编辑时回调
   */
  onEdit?: (editor: CodeEditorInstance) => void;

  /**
   * 发生保存（Ctrl + S）时回调
   */
  onSave?: (editor: CodeEditorInstance) => void;

  /**
   * 编辑器可用时回调
   */
  onReady?: (editor: CodeEditorInstance) => void;
}

export interface CodeEditorInstance {
  /**
   * 异步获取编辑器当前文本
   */
  getValue(options?: {
    preserveBOM: boolean;
    lineEnding: "\n" | "\r\n";
  }): Promise<string>;

  /**
   * 设置编辑器当前文本
   * @param value
   */
  setValue(value: string): void;

  /**
   * 聚焦编辑器
   */
  focus(): void;
}

// 获取值时自增引用
let nextValueKey = 0;
export function CodeEditor(props: CodeEditorProps) {
  const [ready, setReady] = useState(false);
  const {
    options,
    autoFocus,
    loadingPlaceholder,
    className,
    style,
    onEdit,
    onReady,
    onSave,
  } = props;

  const handler = useLast({ onEdit, onReady, onSave });

  const iframeRef = useRef<HTMLIFrameElement>(null);
  const valueCallbackMap = useRef(new Map<string, Function>());

  useEffect(() => {
    if (!iframeRef.current) {
      return () => null;
    }
    let instance: CodeEditorInstance;
    const callHandler = (method: keyof typeof handler.current) => {
      if (handler.current && typeof handler.current[method] === "function") {
        handler.current[method](instance);
      }
    };
    const receive = (evt: MessageEvent) => {
      if (evt.source !== iframeRef.current.contentWindow) {
        return;
      }
      const message = decodeMessage(evt.data);
      if (!message) {
        return;
      }
      const send = (type: string, payload?: any) => {
        (evt.source as WindowProxy).postMessage(
          encodeMessage(type, payload),
          "https://imgcache.qq.com"
        );
      };
      const { type, payload } = message;
      switch (type) {
        case "ready": {
          send("create", {
            language: "javascript",
            autoFocus,
            ...(options || null),
          });
          instance = {
            focus: () => send("focus"),
            getValue: option =>
              new Promise(resolve => {
                const key = nextValueKey;
                nextValueKey += 1;
                send("get-value", { key, option });
                valueCallbackMap.current.set(key.toString(), resolve);
              }),
            setValue: value => send("set-value", { value }),
          };
          callHandler("onReady");
          setReady(true);
          break;
        }
        case "value": {
          const { key, value } = payload;
          const resolve = valueCallbackMap.current.get(String(key));
          if (resolve) {
            valueCallbackMap.current.delete(String(key));
            resolve(value);
          }
          break;
        }
        case "edit": {
          callHandler("onEdit");
          break;
        }
        case "save": {
          callHandler("onSave");
          break;
        }
      }
    };
    window.addEventListener("message", receive);
    return () => window.removeEventListener("message", receive);
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  return (
    <div
      className={classNames("tea-code-editor", className)}
      style={mergeStyle({ position: "relative" }, style)}
    >
      <iframe
        title="code-editor"
        ref={iframeRef}
        src="https://imgcache.qq.com/qcloud/vendors/monaco-editor/frame/editor.html"
        className="tea-code-editor-frame"
        style={{ width: "100%", height: "100%" }}
        frameBorder="no"
      />
      {!ready && (
        <div
          className="tea-code-editor-loading"
          style={{ position: "absolute", left: 0, top: 0, bottom: 0, right: 0 }}
        >
          {typeof loadingPlaceholder === "string" ? (
            <div
              style={{
                height: 30,
                lineHeight: 30,
                textAlign: "center",
                opacity: 0.5,
              }}
            >
              {loadingPlaceholder}
            </div>
          ) : (
            loadingPlaceholder
          )}
        </div>
      )}
    </div>
  );
}

function decodeMessage(message: string) {
  try {
    const { type, payload } = JSON.parse(message);
    if (type) {
      return { type, payload };
    }
  } catch (err) {
    // continue
  }
  return null;
}

function encodeMessage(type: string, payload?: any) {
  return JSON.stringify({ type, payload });
}

function useCommunication(iframeRef: MutableRefObject<HTMLIFrameElement>) {}
