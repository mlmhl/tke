import React, { useState, useEffect, useRef, useCallback } from "react";
import classNames from "classnames";
import moment, { Moment, isMoment } from "moment";
import { ControlledProps, useDefaultValue } from "../form/controlled";
import CalendarPart from "../calendar/CalendarPart";
import { CalendarTable, getTimeRange } from "../calendar/CalendarTable";
import { Combine } from "../_type";
import { TimeSupportWrapper } from "./TimeSupportWrapper";
import { Input } from "../input/Input";
import { useTranslation } from "../i18n";
import { CommonDatePickerProps } from "./DatePickerProps";
import { getYearMonthDate, DatePickerTrigger } from "./util";
import { getHourMinuteSecond, getValidTimeValue } from "../timepicker/util";
import { TimeDisabledProps } from "../timepicker/TimeProps";
import { DropdownBox } from "../dropdown";
import {
  RangeDateType,
  showTimeType,
  CalendarTableType,
  DateChangeContext,
} from "../calendar/DateProps";
import { withStatics } from "../_util/with-statics";
import { useDefault } from "../_util/use-default";
import { Popover } from "../popover/Popover";

export interface RangePickerProps
  extends Combine<CommonDatePickerProps, ControlledProps<RangeDateType>> {
  /**
   * 分隔符
   * @default ~
   */
  separator?: string;

  /**
   * 是否开启时间选择，可传递对象设定时间选择配置
   */
  showTime?: showTimeType<RangeDateType>;

  /**
   * 不可选的日期
   */
  disabledDate?: (date: Moment, startDate?: Moment) => boolean;

  /**
   * 不可选的时间
   */
  disabledTime?: (
    dates: RangeDateType,
    partial: "start" | "end"
  ) => TimeDisabledProps;
}

const getFormat = showTime => (showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD");

export function isValidRangeValue(value: any) {
  return Array.isArray(value) && isMoment(value[0]) && isMoment(value[1]);
}

export const RangePicker = withStatics(
  function RangePicker(props: RangePickerProps) {
    const t = useTranslation(moment);

    const {
      header,
      className,
      style,
      value,
      onChange,
      showTime,
      disabled,
      separator = "~",
      format: _format,
      placeholder = showTime ? t.selectTime : t.selectDate,
      defaultOpen = false,
      open,
      onOpenChange = () => null,
      placement = "bottom-start",
      placementOffset = 5,
      closeOnScroll = true,
      ...restProps
    } = useDefaultValue(props, [null, null]);

    const format = _format || getFormat(showTime);

    // 当前面板类型
    const [type, setType] = useState<[CalendarTableType, CalendarTableType]>([
      "date",
      "date",
    ]);

    // 当前左/右面板展示时间
    const [curStartView, setStartCurView] = useState<Moment>(
      getDefaultViewMoment(0)
    );
    const [curEndView, setEndCurView] = useState<Moment>(
      getDefaultViewMoment(1)
    );

    // 当前选中日期
    const [curValue, setCurValue] = useState<RangeDateType>(
      isValidRangeValue(value)
        ? [value[0].clone(), value[1].clone()]
        : [null, null]
    );

    // 上次选中日期
    const preValidValueRef = useRef<RangeDateType>(value || [null, null]);

    // 选择器是否展开
    const [active, setActive] = useDefault(open, defaultOpen, onOpenChange);

    // 输入框显示值
    const inputRef = useRef<HTMLInputElement>(null);
    const getInputValue = useCallback(
      (value: RangeDateType): string => {
        const [start, end] = value || [null, null];
        if (isMoment(start) && isMoment(end)) {
          return `${start
            .locale(t.locale)
            .format(format)} ${separator} ${end
            .locale(t.locale)
            .format(format)}`;
        }
        return "";
      },
      [format, separator, t.locale]
    );
    const [inputValue, setInputValue] = useState<string>(
      getInputValue(curValue)
    );

    useEffect(() => {
      setCurValue(
        isValidRangeValue(value)
          ? [value[0].clone(), value[1].clone()]
          : [null, null]
      );
      setInputValue(getInputValue(value));
    }, [format, separator, value, getInputValue]);

    function handleChange(
      value: RangeDateType,
      context: DateChangeContext
    ): void {
      // 同步日期/时间
      if (showTime && isValidRangeValue(value)) {
        value = syncDate(value, context.type); // eslint-disable-line no-param-reassign
      }

      setCurValue(value);
      // moment 更改后直接获取值（format）可能拿到是之前值
      setTimeout(() => setInputValue(getInputValue(value)), 0);

      // 没有时间选择时没有二次确认选中
      if (!showTime && isValidRangeValue(value)) {
        onChange(value, context);
        handleClose();
      }
    }

    function handleOk(event): void {
      let value = curValue;
      if (isValidRangeValue(curValue) && curValue[0].isAfter(curValue[1])) {
        value = [curValue[1], curValue[0]];
        setCurValue(value);
      }
      onChange(value, { event });
      handleClose();
    }

    function handleOpen(): void {
      if (disabled) {
        return;
      }
      setActive(true);
      setType(["date", "date"]);
    }

    function handleClose(): void {
      setInputValue(getInputValue(value));
      setActive(false);
    }

    /**
     * 同步日期/时间
     * 如果当前修改为日期，则同步上次时间并修正；
     * 如果当前修改为时间，则同步上次日期；
     */
    function syncDate(
      value: RangeDateType,
      type: CalendarTableType
    ): RangeDateType {
      const preValidValue = preValidValueRef.current;
      const { range, disabledTime = () => ({}) } = props;

      // 如果包含上次选择，则以上次选择为基准同步
      if (isValidRangeValue(preValidValue)) {
        if (type === "date") {
          const timeStart = getValidTimeValue(preValidValue[0], {
            range: getTimeRange(value[0], range),
            ...disabledTime(value, "start"),
          });
          const timeEnd = getValidTimeValue(preValidValue[1], {
            range: getTimeRange(value[1], range),
            ...disabledTime(value, "end"),
          });
          value[0].set(getHourMinuteSecond(timeStart));
          value[1].set(getHourMinuteSecond(timeEnd));
        }
        if (type === "time") {
          value[0].set(getYearMonthDate(preValidValue[0]));
          value[1].set(getYearMonthDate(preValidValue[1]));
        }
        // 如果是首次选择，则将当前时间进行修正
      } else if (type === "date") {
        const timeStart = getValidTimeValue(value[0], {
          range: getTimeRange(value[0], range),
          ...disabledTime(value, "start"),
        });
        const timeEnd = getValidTimeValue(value[1], {
          range: getTimeRange(value[1], range),
          ...disabledTime(value, "end"),
        });
        value[0].set(getHourMinuteSecond(timeStart));
        value[1].set(getHourMinuteSecond(timeEnd));
      }

      preValidValueRef.current = value;
      return value;
    }

    /**
     * 获取 ShowTime 参数
     * @param index 左/右面板 - 0/1
     */
    function getShowTime(index: number): showTimeType<Moment> {
      if (typeof showTime === "object") {
        if (Array.isArray(showTime.defaultValue)) {
          return { ...showTime, defaultValue: showTime.defaultValue[index] };
        }
        return showTime as showTimeType<Moment>;
      }
      return !!showTime;
    }

    /**
     * 获取左右面板 range
     */
    function getRange(range): [RangeDateType, RangeDateType] {
      const [rangeMin, rangeMax] = range || [null, null];
      const endPreEnd = moment(curEndView)
        .subtract(1, "month")
        .endOf("month");
      const startNxtStart = moment(curStartView)
        .add(1, "month")
        .startOf("month");

      return [
        [rangeMin, endPreEnd.isAfter(rangeMax) ? rangeMax : endPreEnd],
        [startNxtStart.isBefore(rangeMin) ? rangeMin : startNxtStart, rangeMax],
      ];
    }

    /**
     * 获取面板默认展示时间
     * @param index 左/右面板 - 0/1
     */
    function getDefaultViewMoment(index: number): Moment {
      const showTime = getShowTime(index);
      const time =
        showTime && typeof showTime === "object"
          ? showTime.defaultValue
          : undefined;

      // 没有初始值
      if (!isValidRangeValue(value)) {
        let m;
        if (!time) {
          m = moment();
        } else {
          m = moment(getHourMinuteSecond(time as Moment));
        }
        return index === 0 ? moment(m).subtract(1, "month") : m;
      }

      // 初始值在同个月
      if (value[0].isSame(value[1], "month")) {
        return index === 0 ? moment(value[1]).subtract(1, "month") : value[1];
      }

      return value[index];
    }

    return (
      <Popover
        trigger={[
          DatePickerTrigger,
          { onOpen: handleOpen, onClose: handleClose },
        ]}
        visible={active}
        onVisibleChange={setActive}
        placement={placement}
        placementOffset={placementOffset}
        closeOnScroll={closeOnScroll}
        overlay={
          <DropdownBox>
            <CalendarPart.Panel rangeMode timeMode={type[0] === "time"}>
              {!!header && <CalendarPart.Header>{header}</CalendarPart.Header>}
              <TimeSupportWrapper
                {...restProps}
                showTime={showTime}
                value={curValue}
                onChange={handleChange}
                onOk={handleOk}
                type={type}
                onTypeChange={types =>
                  setType(types as [CalendarTableType, CalendarTableType])
                }
              >
                {({ type, onTypeChange, range, ...props }) => {
                  const [startRange, EndRange] = getRange(range);
                  return (
                    <>
                      <CalendarTable
                        {...props}
                        rangeType="start"
                        range={startRange}
                        type={type[0]}
                        onTypeChange={t => onTypeChange([t, type[1]])}
                        showTime={getShowTime(0)}
                        curViewMoment={curStartView}
                        onCurViewMomentChange={date => {
                          if (!curEndView.isAfter(date, "month")) {
                            setEndCurView(moment(date).add(1, "month"));
                          }
                          setStartCurView(date);
                        }}
                      />
                      <CalendarTable
                        {...props}
                        rangeType="end"
                        range={EndRange}
                        type={type[1]}
                        onTypeChange={t => onTypeChange([type[0], t])}
                        showTime={getShowTime(1)}
                        curViewMoment={curEndView}
                        onCurViewMomentChange={date => {
                          if (!curStartView.isBefore(date, "month")) {
                            setStartCurView(moment(date).subtract(1, "month"));
                          }
                          setEndCurView(date);
                        }}
                      />
                    </>
                  );
                }}
              </TimeSupportWrapper>
            </CalendarPart.Panel>
          </DropdownBox>
        }
      >
        <div
          className={classNames(
            `tea-date${showTime ? "time" : ""}picker`,
            className
          )}
          style={style}
        >
          <div className={`tea-date${showTime ? "time" : ""}picker__input`}>
            <Input
              ref={inputRef}
              maxLength={8}
              disabled={disabled}
              placeholder={placeholder}
              value={inputValue}
              onFocus={() => inputRef.current.blur()}
            />
          </div>
        </div>
      </Popover>
    );
  },
  { defaultLabelAlign: "middle" }
);
