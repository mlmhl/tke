import React, { Fragment, useRef, useState, useEffect } from "react";
import classNames from "classnames";
import { Combine, StyledProps } from "../_type";
import { Dropdown, DropdownProps, CommonDropdownProps } from "../dropdown";
import { List } from "../list";
import { useTranslation } from "../i18n";
import { ControlledProps, useDefaultValue } from "../form";
import { SelectOptionWithGroup } from "./SelectOption";
import { SelectMultiple } from "./SelectMultiple";
import { SizeType } from "../input";
import { SearchBox } from "../searchbox";
import { EmptyTip } from "../tips";

const noop = () => null;

export interface SelectProps
  extends Combine<CommonDropdownProps, StyledProps, ControlledProps<string>> {
  /**
   * 下拉选框类型，默认为 `native`，使用原生下拉框
   *
   * 设置为 `simulate` 则使用模拟下拉框
   *
   * @default "native"
   */
  type?: "native" | "simulate";

  /**
   * 下拉选项列表
   */
  options?: SelectOptionWithGroup[];

  /**
   * 分组
   */
  groups?: {
    [groupKey: string]: React.ReactNode;
  };

  /**
   * 占位符
   * @default "请选择"（已处理国际化）
   */
  placeholder?: string;

  /**
   * 支持搜索，仅对 `type = "simulate"` 有效
   */
  searchable?: boolean;

  /**
   * 自定义搜索筛选规则
   *
   * 默认根据输入值筛选
   */
  filter?: (inputValue: string, option: SelectOptionWithGroup) => boolean;

  /**
   * 搜索值变化回调
   */
  onSearch?: (inputValue: string) => void;

  /**
   * 展开时回调，仅对 `type = "simulate"` 有效
   */
  onOpen?: DropdownProps["onOpen"];

  /**
   * 收起时回调，仅对 `type = "simulate"` 有效
   */
  onClose?: DropdownProps["onClose"];

  /**
   * 下拉选框的外观，仅对 `type = "simulate"` 有效
   *
   * - `default` 无边框，适用于页面标题和表格内
   * - `button` 为按钮风格，有边框，多用于操作栏中
   * - `link` 为超链接风格
   * - `filter` 为过滤组件风格，多用于表头筛选
   * - `pure` 无额外样式
   *
   * 原有 `raw` 类型建议使用 `pure` 进行改造
   *
   * @default "default"
   */
  appearence?: DropdownProps["appearence"];

  /**
   * 是否禁用下拉选择
   * @default false
   */
  disabled?: boolean;

  /**
   * 下拉按钮的内容，只对 `type = "simulate"` 有效，如果不传，默认会使用选中的选项的内容
   */
  button?: DropdownProps["button"];

  /**
   * 下拉按钮尺寸，使用 `"full"` 撑满容器宽度
   */
  size?: SizeType | "auto";

  /**
   * `options` 滚动至底部的回调，只对 `type = "simulate"` 有效
   */
  onScrollBottom?: (event: React.UIEvent) => void;

  /**
   * 弹出区域尺寸（宽度）是否同步按钮尺寸，仅对 `type = "simulate"` 有效
   *
   * @default false
   */
  boxSizeSync?: boolean;

  /**
   * 弹出区域自定义类名，仅对 `type = "simulate"` 有效
   */
  boxClassName?: DropdownProps["boxClassName"];

  /**
   * 弹出区域自定义样式，仅对 `type = "simulate"` 有效
   */
  boxStyle?: DropdownProps["boxStyle"];

  /**
   * 状态提示，仅对 `type = "simulate"` 有效
   *
   * 可使用字符串或 [StatusTip](/component/tips) 相关组件
   */
  tips?: React.ReactNode;
}

function groupBy(options: SelectOptionWithGroup[]): SelectOptionWithGroup[][] {
  const groups = [];
  options.forEach((opt, index) => {
    const { groupKey } = opt;
    if (index === 0 || groupKey !== options[index - 1].groupKey) {
      groups.push([]);
    }
    groups[groups.length - 1].push(opt);
  });
  return groups;
}

export function Select(props: SelectProps) {
  const t = useTranslation();
  const {
    value,
    onChange,
    options: _options = [],
    groups = {},
    placeholder = t.pleaseSelect,
    disabled,
    button,
    size,
    type,
    onScrollBottom,
    className,
    style,
    boxSizeSync,
    boxClassName,
    boxStyle = {},
    onOpen = noop,
    onClose = noop,
    searchable,
    onSearch = noop,
    filter = (inputValue: string, { text, value }: SelectOptionWithGroup) => {
      const optionText = String(typeof text === "string" ? text : value);
      return !searchable || optionText.includes(inputValue);
    },
    ...dropdownProps
  } = useDefaultValue(props, null);

  const dropdownRef = useRef<HTMLDivElement>(null);
  const [dropdownWidth, setDropdownWidth] = useState<number>(null);

  useEffect(() => {
    if (dropdownRef.current) {
      setDropdownWidth(dropdownRef.current.clientWidth);
    }
  }, [size, value]);

  const InputRef = useRef<HTMLInputElement>(null);
  const [inputValue, setInputValue] = useState<string>("");
  function focus() {
    setInputValue("");
    setTimeout(() => {
      if (InputRef.current) {
        InputRef.current.focus();
      }
    }, 100); // 第一次展开时 Input 还未渲染
  }

  // 筛选
  const options = _options.filter(options => filter(inputValue, options));

  const selected = value != null && options.find(x => x.value === value);

  const hasGroup = !!options.find(opt => !!opt.groupKey);

  let buttonText: React.ReactNode = placeholder || t.pleaseSelect;
  if (selected) {
    buttonText =
      typeof selected.text === "undefined" ? selected.value : selected.text;
  }

  // 模拟选择下拉组件
  if (type === "simulate") {
    // 同步宽度
    if (boxSizeSync && dropdownWidth) {
      Object.assign(boxStyle, {
        minWidth: dropdownWidth,
        maxWidth: dropdownWidth,
      });
    }

    let { tips } = props;
    if (!tips && options.length === 0) {
      tips = <EmptyTip />;
    }
    tips = tips ? <List.StatusTip>{tips}</List.StatusTip> : null;

    return (
      <Dropdown
        updateOnChildrenChange
        ref={dropdownRef}
        clickClose={false}
        style={style}
        className={className}
        boxStyle={boxStyle}
        boxClassName={boxClassName}
        size={size}
        disabled={disabled}
        button={typeof button !== "undefined" ? button : buttonText}
        onOpen={() => {
          onOpen();
          focus();
        }}
        onClose={onClose}
        {...dropdownProps}
      >
        {close => (
          <>
            {searchable && (
              <SearchBox
                simple
                ref={InputRef}
                value={inputValue}
                onChange={value => {
                  setInputValue(value);
                  onSearch(value);
                }}
                onClear={focus}
              />
            )}
            <List
              type={hasGroup ? "option-group" : "option"}
              onScrollBottom={onScrollBottom}
            >
              {tips}
              {options.map((opt, index) => {
                const item = (
                  <List.Item
                    key={opt.value}
                    disabled={opt.disabled}
                    selected={opt === selected}
                    onClick={event => {
                      onChange(opt.value, { event });
                      close();
                    }}
                    tooltip={opt.tooltip}
                  >
                    {typeof opt.text === "undefined" ? opt.value : opt.text}
                  </List.Item>
                );
                if (
                  opt.groupKey &&
                  (index === 0 || opt.groupKey !== options[index - 1].groupKey)
                ) {
                  return (
                    <Fragment key={opt.value}>
                      <List.GroupLabel>{groups[opt.groupKey]}</List.GroupLabel>
                      {item}
                    </Fragment>
                  );
                }
                return item;
              })}
            </List>
          </>
        )}
      </Dropdown>
    );
  }

  // 原生下拉组件
  return (
    <select
      className={classNames("tea-select", className, {
        [`size-${
          size === "full" || size === "auto" ? `${size}-width` : size
        }`]: size,
      })}
      style={style}
      disabled={disabled}
      value={value || ""}
      placeholder={placeholder}
      onChange={
        disabled ? null : event => onChange(event.target.value, { event })
      }
    >
      {typeof placeholder === "string" && (
        <option disabled={!!value}>{placeholder}</option>
      )}
      {options.find(opt => !!opt.groupKey)
        ? groupBy(options).map(group => {
            const { value, groupKey } = group[0];
            if (!groupKey) {
              return group.map(opt => (
                <option
                  key={opt.value}
                  value={opt.value}
                  disabled={opt.disabled}
                  title={
                    typeof opt.tooltip === "string" ? opt.tooltip : undefined
                  }
                >
                  {typeof opt.text === "undefined" ? opt.value : opt.text}
                </option>
              ));
            }
            return (
              <optgroup key={value} label={(groups[groupKey] as string) || ""}>
                {group.map(opt => (
                  <option
                    key={opt.value}
                    value={opt.value}
                    disabled={opt.disabled}
                    title={
                      typeof opt.tooltip === "string" ? opt.tooltip : undefined
                    }
                  >
                    {typeof opt.text === "undefined" ? opt.value : opt.text}
                  </option>
                ))}
              </optgroup>
            );
          })
        : options.map(opt => (
            <option
              key={opt.value}
              value={opt.value}
              disabled={opt.disabled}
              title={typeof opt.tooltip === "string" ? opt.tooltip : undefined}
            >
              {typeof opt.text === "undefined" ? opt.value : opt.text}
            </option>
          ))}
    </select>
  );
}

Select.Multiple = SelectMultiple;
Select.defaultLabelAlign = "middle";
