import React, { useRef } from "react";
import { RefHandler } from "react-popper";
import { Overlay, OverlayLayerProps } from "../overlay";
import { useDelayVisible } from "./useDelayVisible";
import { useParentScroll } from "../_util/use-parent-scroll";
import { buildinTriggers, Trigger, TriggerWithProps } from "./trigger";
import { mergeStyle } from "../_util/merge-style";
import { DomRef } from "../domref";
import { mergeRefs } from "../_util/merge-refs";

export interface PopoverProps {
  /**
   * 触发弹出层的内容，会直接渲染出来
   *
   * 内容触发弹出层的方式，由 `trigger` 属性指定
   *
   * 如果传入的不是 `ReactElement`（如文本、数字等），则渲染时会套一层 `span`
   */
  children?: React.ReactNode;

  /**
   * 弹出层内容
   * @docType React.ReactNode | ((props: OverlayContentProps) => JSX.Element)
   */
  overlay?: OverlayLayerProps["content"];

  /**
   * 触发弹出层显示的事件
   *
   * - `hover`：用户鼠标进入渲染内容时，显示浮层；离开渲染内容时，隐藏浮层。
   *   使用该交互请保证 `children` 可以接收 `onMouseEnter` 和 `onMouseLeave` 事件
   *
   * - `click`：用户在渲染内容上点击鼠标时，显示浮层；在渲染内容以及浮层外点击时，隐藏浮层。
   *   使用该交互请保证 `children` 可以接收 `onClick` 事件
   *
   * - 传入自定义组件以实现自定义弹出逻辑
   *
   * @default "hover"
   */
  trigger?: keyof typeof buildinTriggers | Trigger | TriggerWithProps;

  /**
   * 传入 `visible` 则表示使用受控模式来控制弹出层的显示，请处理 `onVisibleChange` 方法
   */
  visible?: boolean;

  /**
   * `visible` 变化时回调
   */
  onVisibleChange?: (visbile: boolean) => void;

  /**
   * 气泡默认是否打开
   * @default false
   */
  defaultVisible?: boolean;

  /**
   * 打开浮层前的延时
   */
  openDelay?: number;

  /**
   * 关闭浮层前的延时
   */
  closeDelay?: number;

  /**
   * 是否在容器滚动发生关闭
   * @default false
   */
  closeOnScroll?: boolean;

  /**
   * 气泡弹出的位置
   * @default "top"
   */
  placement?: OverlayLayerProps["placement"];

  /**
   * 弹出位置偏离参考位置的位移
   * @default 10
   */
  placementOffset?: OverlayLayerProps["placementOffset"];

  /**
   * 出现动画滑动距离
   */
  animationScaleFrom?: OverlayLayerProps["animationScaleFrom"];

  /**
   * 自定义定位参考信息
   * @see https://github.com/FezVrasta/react-popper#usage-without-a-reference-htmlelement
   */
  referenceElement?: OverlayLayerProps["referenceElement"];

  /**
   * 是否在 `resize` 和 `scroll` 发生时更新位置
   */
  updateOnDimensionChange?: OverlayLayerProps["updateOnDimensionChange"];

  /**
   * 自定义覆盖层样式
   */
  overlayStyle?: React.CSSProperties;

  /**
   * 动画事件
   */
  transitionTimeout?: OverlayLayerProps["transitionTimeout"];
}

export type PopoverRenderFunction = (props: PopupRenderProps) => JSX.Element;

export interface PopupRenderProps {
  ref: RefHandler;
  open: () => void;
  close: () => void;
}

export type PopupTrigger = "click" | "hover";

export function Popover(props: PopoverProps) {
  const {
    overlay,
    trigger = "hover",
    placement = "top",
    placementOffset = 10,
    children,
    closeOnScroll,
    overlayStyle,
    openDelay,
    closeDelay,
    updateOnDimensionChange,
    animationScaleFrom,
    transitionTimeout,
  } = props;

  const overlayRef = useRef(null);
  const childrenRef = useRef(null);

  const { visible, setVisible } = useDelayVisible(props);

  // 设置了 closeOnScroll，则使用
  useParentScroll(
    childrenRef,
    visible && closeOnScroll && (() => setVisible(false))
  );

  let Trigger: Trigger;
  let triggerExtraProps: any = {};

  // 使用指定的触发交互组件
  if (typeof trigger === "string") {
    Trigger = buildinTriggers[trigger];
  }
  // 支持附加 props 的触发器
  else if (Array.isArray(trigger)) {
    [Trigger, triggerExtraProps] = trigger;
  }
  // 本身就是 Trigger 组件
  else {
    Trigger = trigger;
  }
  // fallback
  Trigger = Trigger || buildinTriggers.empty;

  return (
    <Trigger
      {...triggerExtraProps}
      overlayElementRef={overlayRef}
      childrenElementRef={childrenRef}
      visible={visible}
      setVisible={setVisible}
      openDelay={openDelay}
      closeDelay={closeDelay}
      render={({ overlayProps, childrenProps, referenceElement }) => (
        <Overlay
          layers={[
            <Overlay.Layer
              key="popover"
              visible={visible}
              placement={placement}
              placementOffset={placementOffset}
              animationScaleFrom={animationScaleFrom}
              referenceElement={props.referenceElement || referenceElement}
              content={overlay}
              overlayRef={overlayElement => {
                overlayRef.current = overlayElement;
              }}
              overlayProps={{
                ...overlayProps,
                style: mergeStyle(
                  {
                    // 已经隐藏之后，动画过程不响应事件
                    pointerEvents: visible ? null : "none",
                  },
                  overlayProps.style,
                  overlayStyle
                ),
              }}
              updateOnDimensionChange={updateOnDimensionChange}
              transitionTimeout={transitionTimeout}
            />,
          ]}
        >
          {ref => (
            <DomRef {...childrenProps} ref={mergeRefs(ref, childrenRef)}>
              {React.isValidElement(children) ? (
                children
              ) : (
                <span>{children}</span>
              )}
            </DomRef>
          )}
        </Overlay>
      )}
    />
  );
}
