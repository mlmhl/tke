import React, { useState, useEffect, useRef } from "react";
import classNames from "classnames";
import { StyledProps, Combine } from "../_type";
import { ControlledProps, useDefaultValue } from "../form/controlled";
import { withStatics } from "../_util/with-statics";
import { getPrecision } from "../_util/get-precision";

export interface InputNumberProps
  extends Combine<StyledProps, ControlledProps<number>> {
  /** 最小值 */
  min?: number;

  /** 最大值 */
  max?: number;

  /**
   * 使用按钮增减时的步长
   * @default 1
   */
  step?: number;

  /** 单位 */
  unit?: string;

  /** 是否可用 */
  disabled?: boolean;
}

const DISABLED_CLS = "is-disabled";

/**
 * 数字输入组件
 */
export const InputNumber = withStatics(
  function InputNumber(props: InputNumberProps) {
    const { style, unit, disabled, className } = props;
    const { minus, input, plus } = useInputNumberHooks(props);
    const precision = getPrecision(props.step);

    return (
      <span
        className={classNames("tea-inputnum", className, {
          [DISABLED_CLS]: disabled,
        })}
        style={style}
      >
        <span
          className={classNames("tea-inputnum__minus", {
            [DISABLED_CLS]: minus.disabled,
          })}
          onMouseDown={disabled ? () => null : minus.handleMouseDown}
        >
          -
        </span>
        <input
          className="tea-input"
          value={
            typeof input.value === "number"
              ? input.value.toFixed(precision)
              : input.value
          }
          onChange={input.handleChange}
          onBlur={input.handleBlur}
          onKeyDown={input.handleKeyDown}
          disabled={disabled}
        />
        <span
          className={classNames("tea-inputnum__plus", {
            [DISABLED_CLS]: plus.disabled,
          })}
          onMouseDown={disabled ? () => null : plus.handleMouseDown}
        >
          +
        </span>
        {unit && <div className="tea-form__help-text--inline">{unit}</div>}
      </span>
    );
  },
  {
    defaultLabelAlign: "middle",
  }
);

/**
 * InputNumber 状态管理
 */
function useInputNumberHooks(props: InputNumberProps) {
  let { step } = props;
  const { min, max, value, onChange } = useDefaultValue(props, 0);

  const isValidNumber = (num: any) =>
    typeof num === "number" && !Number.isNaN(num);

  step = isValidNumber(step) ? step : 1;

  const precision = getPrecision(step);

  const hasMax = isValidNumber(max);
  const hasMinus = isValidNumber(min);

  const [inputValue, setInputValue] = useState<string>(null);
  const hasInputValue = inputValue !== null;

  const parse = (newValue: string): number =>
    newValue.trim() === "" ? 0 : parseFloat(newValue);

  const getCurrentValue = () => {
    let currentValue = value;
    if (hasInputValue && /\d/.test(inputValue)) {
      currentValue = parse(inputValue);
      // 解析失败，退回当前值
      if (Number.isNaN(currentValue)) {
        currentValue = value;
      }
    }
    return currentValue;
  };

  const canMinus = (value: number) => !hasMinus || value > min;
  const canPlus = (value: number) => !hasMax || value < max;

  const commit = (_newValue: string | number, event: React.SyntheticEvent) => {
    let newValue = _newValue;
    // 从 input 回调过来的，是字符串
    if (typeof newValue === "string") {
      newValue = parse(newValue);
    }
    // 不能小于最小值
    if (hasMinus) {
      newValue = Math.max(min, newValue);
    }
    // 不能大于最大值
    if (hasMax) {
      newValue = Math.min(max, newValue);
    }
    // 解析失败，还原旧值
    if (Number.isNaN(newValue)) {
      newValue = value;
    }
    // 处理精度
    newValue = parse(newValue.toFixed(precision));

    if (typeof onChange === "function") {
      onChange(newValue, { event });
    } else {
      console.warn("InputNumber 是受控组件，请传入 onChange 属性处理值变化");
    }
  };

  // value 发生变更，清空暂存的值
  useEffect(() => setInputValue(null), [value]);

  // 长按增减按钮会持续操作，鼠标抬起，或者组件销毁时要清空
  const autoStepTimer = useRef<any>(0);
  const clear = () => clearTimeout(autoStepTimer.current);
  useEffect(() => {
    window.addEventListener("mouseup", clear, true);

    // destroy
    return () => {
      clear();
      window.removeEventListener("mouseup", clear);
    };
  }, []);

  // 为按钮提供步长调整逻辑
  const stepper = (step: number) => {
    // 步长的符号影响是否允许进行下一步长的判断方法
    const canStep = step > 0 ? canPlus : canMinus;
    return {
      disabled: !canStep(value),

      // 点击按钮的时候，先变更一次。然后，只要鼠标不抬起，自动连续变更
      handleMouseDown: (evt: React.MouseEvent) => {
        let currentValue = getCurrentValue();
        const performStep = () => {
          if (canStep(currentValue)) {
            commit((currentValue += step), evt);
          }
        };
        performStep();

        clear();
        // 1 秒后，开始自动递增
        autoStepTimer.current = setTimeout(() => {
          const autoPerform = () => {
            performStep();
            autoStepTimer.current = setTimeout(autoPerform, 50);
          };
          autoPerform();
        }, 700);

        // 保留事件内容，否则在自动步长执行的时候，事件不可用
        evt.persist();

        // 阻止事件变成 blur 事件，导致二次设置
        evt.preventDefault();
      },
    };
  };

  return {
    minus: stepper(-step),
    plus: stepper(step),
    input: {
      value: hasInputValue ? inputValue : value,
      handleChange: (evt: React.ChangeEvent<HTMLInputElement>) => {
        setInputValue(evt.target.value);
      },
      handleBlur: (evt: React.FocusEvent<HTMLInputElement>) => {
        commit(evt.target.value, evt);
        setInputValue(null);
      },
      handleKeyDown: (evt: React.KeyboardEvent<HTMLInputElement>) => {
        const currentValue = getCurrentValue();
        if (canPlus(currentValue) && evt.keyCode === 38) {
          // ArrowUp
          evt.preventDefault();
          commit(currentValue + step, evt);
        } else if (canMinus(currentValue) && evt.keyCode === 40) {
          // ArrowDown
          evt.preventDefault();
          commit(currentValue - step, evt);
        }
        // Enter
        if (evt.keyCode === 13) {
          commit(currentValue, evt);
          setInputValue(null);
        }
      },
    },
  };
}
