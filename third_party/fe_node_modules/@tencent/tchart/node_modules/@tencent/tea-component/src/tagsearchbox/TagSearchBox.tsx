/* eslint-disable */
import React from "react";
import classNames from "classnames";
import clone from "clone";
import { Tag, TagValue } from "./Tag";
import { TagInput } from "./TagInput";
import { AttributeValue } from "./AttributeSelect";
import { withClickOutSide } from "../_util/with-click-outside";
import { withTranslation, TranslationProps } from "../i18n";
import { Bubble } from "../bubble";
import { Modal } from "../modal";
import { StyledProps } from "../_type";
import { Icon } from "../icon";
import { TagSearchBoxContext } from "./TagSearchBoxContext";

export interface TagSearchBoxProps extends StyledProps {
  /**
   * 要选择过滤的资源属性的集合
   */
  attributes?: AttributeValue[];

  /**
   * 搜索框中默认包含的标签值的集合
   */
  defaultValue?: any[];

  /**
   * 配合 onChange 作为受控组件使用
   */
  value?: any[];

  /**
   * 搜索框收起后宽度
   * @default 210
   */
  minWidth?: string | number;

  /**
   * 当搜索框中新增、修改或减少标签时调用此函数
   */
  onChange?: (tags: any[]) => void;

  /**
   * 搜索框中提示语
   *
   * @default "多个关键字用竖线 “|” 分隔，多个过滤标签用回车键分隔" （已处理国际化）
   */
  tips?: string;

  /**
   * 资源属性选择下拉框提示
   *
   * @default "选择资源属性进行过滤" （已处理国际化）
   */
  attributesSelectTips?: string;

  /**
   * 隐藏帮助信息
   *
   * @default false
   */
  hideHelp?: boolean;
}

export interface TagSearchBoxState {
  /**
   * 搜索框是否为展开状态
   */
  active: boolean;

  /**
   * 是否展示提示框
   */
  dialogActive: boolean;

  /**
   * 当前光标位置
   */
  curPos: number;

  /**
   * 当前光标（焦点）所在位置的元素类型
   */
  curPosType: FocusPosType;

  /**
   * 是否展示值选择组件
   */
  showSelect: boolean;

  /**
   * 已选标签
   */
  tags: TagValue[];
}

/**
 * 焦点所在位置类型
 */
export enum FocusPosType {
  INPUT,
  INPUT_EDIT,
  TAG,
}

let COUNTER = 0;

@withTranslation
@withClickOutSide("close")
export class TagSearchBox extends React.Component<
  TagSearchBoxProps & TranslationProps
> {
  state: TagSearchBoxState = {
    active: false,
    dialogActive: false,
    curPos: 0,
    curPosType: FocusPosType.INPUT,
    showSelect: true,
    tags: this.props.defaultValue
      ? this.props.defaultValue.map(item => {
          item._key = COUNTER++;
          return item;
        })
      : [],
  };

  componentDidMount() {
    this.resetTagsState(this.props);
  }

  componentWillReceiveProps(nextProps: TagSearchBoxProps) {
    this.resetTagsState(nextProps);
  }

  resetTagsState = (props: TagSearchBoxProps, callback?: Function) => {
    if ("value" in props) {
      const value = props.value.map(item => {
        if (!("_key" in item)) {
          item._key = COUNTER++;
        }
        return item;
      });
      this.setState({ tags: clone(value) }, () => {
        callback && callback();
      });
    }
  };

  open = () => {
    const { active, tags } = this.state;
    if (!active) {
      this.setState({ active: true });
      // 展开时不激活 select 显示
      this.setState({ curPosType: FocusPosType.INPUT, curPos: tags.length });
    } else {
      this.handleTagEvent("click-input", tags.length);
    }
    this.setState({ showSelect: true });
    setTimeout(() => {
      this[`tag-${tags.length}`].moveToEnd();
    }, 100);
  };

  close = () => {
    // 编辑未完成的取消编辑
    const tags = this.state.tags.map((item, index) => {
      if (item._edit) {
        this[`tag-${index}`].editDone();
        item._edit = false;
      }
      return item;
    });

    this.setTags(
      tags,
      () => {
        this.setState({ showSelect: false });
        if (this.state.active) {
          this.setState({ curPos: -1 }, () =>
            this.setState(
              { active: false },
              () => (this[`search-box`].scrollLeft = 0)
            )
          );
        }
      },
      false
    );
  };

  notify = (tags: Array<TagValue>) => {
    const { onChange } = this.props;
    if (!onChange) return;

    const result = [];
    tags.forEach(item => {
      const attr = item.attr || null;
      const { values } = item;
      if (values.length > 0) {
        result.push({ attr, values, _key: item._key, _edit: item._edit });
      }
    });
    onChange(result);
  };

  // Tags 发生变动
  setTags(tags: Array<TagValue>, callback?: Function, notify = true): void {
    const cb = () => {
      notify && this.notify(tags);
      callback && callback();
    };
    // 受控模式
    if (notify && this.props.value) {
      this.resetTagsState(this.props, cb);
    } else {
      this.setState({ tags }, cb);
    }
  }

  /**
   * 点击清除按钮触发事件
   */
  handleClean = (e): void => {
    e.stopPropagation();
    const { tags } = this.state;
    const index = `tag-${0}`;
    if (tags.length <= 0) {
      this[index].setInputValue("");
      return;
    }
    this.setTags([], () =>
      setTimeout(() => {
        this[index].setInputValue("");
        this[index].focusInput();
      }, 0)
    );
    this.setState({ curPos: 0, curPosType: FocusPosType.INPUT });
    // 刷新下拉列表位置
    const input = this[`tag-${tags.length}`];
    if (input) {
      input.scheduleUpdate();
    }
  };

  /**
   * 点击帮助触发事件
   */
  handleHelp = e => {
    e.stopPropagation();
    this.setState({ dialogActive: true });
  };

  /**
   * 点击搜索触发事件
   */
  handleSearch = e => {
    if (!this.state.active) return;
    e.stopPropagation();
    const { curPos, curPosType, tags } = this.state;
    let flag = false;

    const input = this[`tag-${tags.length}`];
    if (input && input.addTagByInputValue) {
      if (input.addTagByInputValue()) {
        flag = true;
      }
    }

    for (let i = 0; i < tags.length; ++i) {
      if (!this[`tag-${i}`] || !this[`tag-${i}`].addTagByEditInputValue) return;
      if (tags[i]._edit && this[`tag-${i}`].addTagByEditInputValue())
        flag = true;
    }

    if (flag) return;

    this.notify(this.state.tags);
    input.focusInput();
  };

  /**
   *  处理Tag相关事件
   */
  handleTagEvent = (type: string, index: number, payload?: any): void => {
    const { tags, active } = this.state;

    switch (type) {
      case "add":
        payload._key = COUNTER++;
        tags.splice(++index, 0, payload);
        this.setTags(tags, () => {
          if (this[`tag-${index}`]) {
            this[`tag-${index}`].focusInput();
          }
        });
        this.setState({ showSelect: false });
        break;

      case "edit":
        this[`tag-${index}`].editDone();
        tags[index].attr = payload.attr;
        tags[index].values = payload.values;
        tags[index]._edit = false;

        this.setTags(tags);
        index++;
        this.setState({ showSelect: false, curPosType: FocusPosType.INPUT });
        break;

      case "edit-cancel":
        this[`tag-${index}`].editDone();

        this.setTags(tags, () => null, false);
        this.setState({ showSelect: false, curPosType: FocusPosType.INPUT });
        break;

      case "editing":
        if ("attr" in payload && tags[index]) tags[index].attr = payload.attr;
        if ("values" in payload && tags[index])
          tags[index].values = payload.values;
        this.setTags(tags, null, false);
        break;

      case "del":
        if (payload === "keyboard") index--;
        if (!tags[index]) break;

        // 检查不可移除
        const { attr } = tags[index];
        if (attr && "removeable" in attr && attr.removeable === false) {
          break;
        }

        tags.splice(index, 1);
        this.setTags(tags, () => {
          this.setState({ curPosType: FocusPosType.INPUT });
        });
        if (payload !== "edit") {
          this.setState({ showSelect: false });
        }
        break;

      // payload 为点击位置
      case "click":
        if (!active) {
          this.open();
          return;
        }
        // 触发修改
        const pos = payload;
        tags[index]._edit = true;
        this.setTags(
          tags,
          () => {
            this.setState({ showSelect: true }, () => {
              this[`tag-${index}`].edit(pos);
            });
          },
          false
        );

        this.setState({ curPosType: FocusPosType.INPUT_EDIT });
        break;

      case "click-input":
        if (payload === "edit") {
          this.setState({ curPosType: FocusPosType.INPUT_EDIT });
        } else {
          this.setState({ curPosType: FocusPosType.INPUT });
        }

        if (!active) {
          this.setState({ active: true });
        }
        this.setState({ showSelect: true });
        break;
    }

    this.setState({ curPos: index });
  };

  render() {
    const {
      active,
      tags,
      curPos,
      curPosType,
      dialogActive,
      showSelect,
    } = this.state;
    const {
      t,
      className,
      style = {},
      minWidth = 210,
      attributes,
      hideHelp,
      tips = t.tagSearchBoxTips,
      attributesSelectTips = t.tagSearchBoxSelectTitle,
    } = this.props;

    // 用于计算 focused 及 isFocused, 判断是否显示选择组件
    // (直接使用 Input 组件内部 onBlur 判断会使得 click 时组件消失)
    let focusedInputIndex = -1;
    if (
      curPosType === FocusPosType.INPUT ||
      curPosType === FocusPosType.INPUT_EDIT
    ) {
      focusedInputIndex = curPos;
    }

    const tagList = tags.map((item, index) => {
      // 补全 attr 属性
      attributes.forEach(attrItem => {
        if (item.attr && attrItem.key && attrItem.key == item.attr.key) {
          item.attr = Object.assign({}, item.attr, attrItem);
        }
      });

      const selectedAttrKeys = [];
      tags.forEach(tag => {
        if (
          tag.attr &&
          item.attr &&
          item._edit &&
          item.attr.key === tag.attr.key
        )
          return null;
        if (tag.attr && tag.attr.key && !tag.attr.reusable) {
          selectedAttrKeys.push(tag.attr.key);
        }
      });

      const useableAttributes = attributes.filter(
        item => selectedAttrKeys.indexOf(item.key) < 0
      );

      return (
        <Tag
          ref={tag => (this[`tag-${index}`] = tag)}
          active={active}
          key={item._key}
          attributes={useableAttributes}
          attr={item.attr}
          values={item.values}
          maxWidth={
            this["search-wrap"] ? this["search-wrap"].clientWidth : null
          }
          focused={
            focusedInputIndex === index && showSelect ? curPosType : null
          }
          dispatchTagEvent={(type, payload) =>
            this.handleTagEvent(type, index, payload)
          }
        />
      );
    });

    const selectedAttrKeys = tags
      .map(item => (item.attr && !item.attr.reusable ? item.attr.key : null))
      .filter(item => !!item);
    const useableAttributes = attributes.filter(
      item => selectedAttrKeys.indexOf(item.key) < 0
    );

    tagList.push(
      <TagInput
        key="__input__"
        ref={input => (this[`tag-${tags.length}`] = input)}
        active={active}
        maxWidth={this["search-wrap"] ? this["search-wrap"].clientWidth : null}
        attributes={useableAttributes}
        isFocused={focusedInputIndex === tags.length && showSelect}
        dispatchTagEvent={(type, payload) =>
          this.handleTagEvent(type, tags.length, payload)
        }
      />
    );

    return (
      <div
        className={classNames("tea-search tea-search--tags", className, {
          "is-active": active,
        })}
        ref={div => (this["search-wrap"] = div)}
        style={active ? style : { ...style, width: minWidth }}
      >
        <div
          className="tea-search__inner"
          onClick={this.open}
          ref={div => (this[`search-box`] = div)}
        >
          <div className="tea-tag-group">
            <TagSearchBoxContext.Provider value={{ attributesSelectTips }}>
              {tagList}
            </TagSearchBoxContext.Provider>
          </div>

          <div
            className="tea-text-weak tea-search__tips"
            style={{ position: "relative" }}
          >
            {tips}
          </div>
          {/* 清除按钮根据 hideHelp 添加类名确定位置 */}
          {!!active && tags.length > 0 && (
            <Bubble content={t.cleanText}>
              <button
                type="button"
                className={classNames("tea-btn tea-btn--icon", {
                  "tea-btn--dismiss": !hideHelp,
                  "tea-btn--info": !!hideHelp,
                })}
                onClick={this.handleClean}
              >
                <Icon type="dismiss" />
              </button>
            </Bubble>
          )}
          {!!active && !hideHelp && (
            <Bubble content={t.helpText}>
              <button
                type="button"
                className="tea-btn tea-btn--icon tea-btn--info"
                onClick={this.handleHelp}
              >
                <Icon type="info" />
              </button>
            </Bubble>
          )}
          <Bubble content={active ? t.searchText : null}>
            <button
              type="button"
              className="tea-btn tea-btn--icon tea-btn--search"
              onClick={this.handleSearch}
            >
              <Icon type="search" />
            </button>
          </Bubble>
        </div>

        <Modal
          visible={dialogActive}
          size="auto"
          caption={t.helpText}
          onClose={() => this.setState({ dialogActive: false })}
          className="ignore-react-onclickoutside"
        >
          <Modal.Body>
            <i
              style={{
                width: 910,
                height: 476,
                backgroundImage: `url(${t.tagSearchBoxHelpImgUrl})`,
                backgroundSize: "contain",
                backgroundRepeat: "no-repeat",
                backgroundPosition: "center",
                display: "inline-block",
              }}
            />
          </Modal.Body>
        </Modal>
      </div>
    );
  }
}
