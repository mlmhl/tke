import React, { forwardRef } from "react";
import ReactDOM from "react-dom";
import { mergeRefs } from "../_util/merge-refs";
import { callBoth } from "../_util/call-both";

interface DomRefProps {
  children?: React.ReactNode;
}

class DomRefInner extends React.Component<
  DomRefProps & { domRef: React.Ref<HTMLElement> }
> {
  public componentDidMount() {
    const dom = ReactDOM.findDOMNode(this) as HTMLElement; // eslint-disable-line react/no-find-dom-node
    const { domRef } = this.props;
    mergeRefs(domRef)(dom);
  }

  public componentDidUpdate() {
    const dom = ReactDOM.findDOMNode(this) as HTMLElement; // eslint-disable-line react/no-find-dom-node
    const { domRef } = this.props;
    mergeRefs(domRef)(dom);
  }

  public componentWillUnmount() {
    const { domRef } = this.props;
    mergeRefs(domRef)(null);
  }

  public render() {
    const { children, domRef, ...props } = this.props;

    let childrenElement = children;
    const attachProps = {};

    // 元素类型的，可以把要求渲染的 childrenProps 和原本的 props 合并
    if (React.isValidElement(childrenElement)) {
      for (const [propName, propValue] of Object.entries(props)) {
        if (typeof propValue === "function") {
          // 子节点之前已经有处理函数，则同时调用
          if (childrenElement.props[propName]) {
            attachProps[propName] = callBoth(
              propValue,
              childrenElement.props[propName]
            );
          } else {
            attachProps[propName] = propValue;
          }
        } else {
          attachProps[propName] = propValue;
        }
      }
      childrenElement = React.cloneElement(childrenElement, attachProps);
      return childrenElement;
    }

    return children;
  }
}

export const DomRef = forwardRef(
  (props: DomRefProps, ref: React.Ref<HTMLElement>) => (
    <DomRefInner {...props} domRef={ref} />
  )
);
