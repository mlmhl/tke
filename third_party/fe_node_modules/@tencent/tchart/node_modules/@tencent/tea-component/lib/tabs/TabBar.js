"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importStar(require("react"));
var classnames_1 = tslib_1.__importDefault(require("classnames"));
var TabItem_1 = require("./TabItem");
var button_1 = require("../button");
function TabBar(_a) {
    var activeId = _a.activeId, tabs = _a.tabs, onActive = _a.onActive, addon = _a.addon, vertical = _a.vertical, maxHeight = _a.maxHeight;
    // 插件区域宽度
    var addonsRef = react_1.useRef(null);
    var _b = tslib_1.__read(react_1.useState(0), 2), addonWidth = _b[0], setAddonWidth = _b[1];
    react_1.useEffect(function () {
        if (addonsRef.current) {
            setAddonWidth(addonsRef.current.clientWidth);
        }
    }, [addon]);
    // Scroll 相关
    var scrollAreaRef = react_1.useRef(null);
    var tabListRef = react_1.useRef(null);
    var buttonRef = react_1.useRef(null);
    var activeItemRef = react_1.useRef(null);
    var _c = tslib_1.__read(react_1.useState(0), 2), offset = _c[0], setOffset = _c[1];
    var _d = tslib_1.__read(react_1.useState(false), 2), scrolling = _d[0], setScrolling = _d[1];
    // resize 或 tabs/addon 变化时重置滚动
    react_1.useEffect(handleScroll, [tabs, addon]);
    react_1.useEffect(function () {
        window.addEventListener("resize", handleScroll);
        return function () { return window.removeEventListener("resize", handleScroll); };
    }, []); // eslint-disable-line react-hooks/exhaustive-deps
    react_1.useEffect(handleActiveItemIntoView, [activeId]);
    // 设置滚动状态
    function handleScroll() {
        var scrolling = getMaxOffset() > 0;
        setScrolling(scrolling);
        // 无需滚动时重置位置
        if (!scrolling) {
            setOffset(0);
        }
        else {
            handleActiveItemIntoView();
        }
    }
    // 处理滚动至当前选中 TabItem
    function handleActiveItemIntoView() {
        setTimeout(function () {
            if (!scrollAreaRef.current || !activeItemRef.current) {
                return;
            }
            var scrollAreaRect = scrollAreaRef.current.getBoundingClientRect();
            var activeItemRect = activeItemRef.current.getBoundingClientRect();
            var _a = tslib_1.__read(vertical
                ? ["top", "bottom"]
                : ["left", "right"], 2), startPropertyName = _a[0], endPropertyName = _a[1];
            var buttonProperty = vertical
                ? buttonRef.current.clientHeight
                : buttonRef.current.clientWidth;
            var startDelta = scrollAreaRect[startPropertyName] -
                activeItemRect[startPropertyName] +
                buttonProperty;
            var endDelta = activeItemRect[endPropertyName] -
                scrollAreaRect[endPropertyName] +
                buttonProperty;
            if (startDelta > 0) {
                setOffset(Math.min(0, offset + startDelta));
            }
            else if (endDelta > 0) {
                setOffset(Math.max(0 - getMaxOffset(), offset - endDelta));
            }
        }, 0);
    }
    // 获取最大滚动偏移
    function getMaxOffset() {
        // 垂直时不指定 maxHeight 不触发滚动
        if (!scrollAreaRef.current || (vertical && !maxHeight)) {
            return 0;
        }
        var propertyName = vertical ? "clientHeight" : "clientWidth";
        var scrollAreaProperty = vertical
            ? maxHeight
            : scrollAreaRef.current[propertyName];
        var tabListProperty = tabListRef.current[propertyName];
        var buttonProperty = buttonRef.current[propertyName];
        if (scrollAreaProperty >= tabListProperty) {
            return 0;
        }
        return tabListProperty - (scrollAreaProperty - buttonProperty * 2);
    }
    // 获取最大单次滚动步长
    function getStep() {
        var propertyName = vertical ? "clientHeight" : "clientWidth";
        return (scrollAreaRef.current[propertyName] - buttonRef.current[propertyName] * 2);
    }
    function handleBackward() {
        setOffset(function (offset) { return Math.min(0, offset + getStep()); });
    }
    function handleForward() {
        setOffset(function (offset) { return Math.max(0 - getMaxOffset(), offset - getStep()); });
    }
    return (react_1.default.createElement("div", { className: "tea-tabs__tabbar" },
        react_1.default.createElement("div", { ref: scrollAreaRef, className: classnames_1.default("tea-tabs__scroll-area", {
                "is-scrolling": scrolling,
            }), style: {
                maxHeight: vertical ? maxHeight : undefined,
                marginRight: addonWidth,
            } },
            react_1.default.createElement("ul", { ref: tabListRef, className: "tea-tabs__tablist", style: {
                    transition: "transform ease-out .2s",
                    transform: vertical
                        ? "translate3d(0, " + offset + "px, 0)"
                        : "translate3d(" + offset + "px, 0, 0)",
                } }, tabs.map(function (tab) { return (react_1.default.createElement(TabItem_1.TabItem, { ref: tab.id === activeId ? activeItemRef : undefined, key: tab.id, label: tab.label, actived: tab.id === activeId, disabled: tab.disabled, onClose: tab.onClose ? function (evt) { return tab.onClose(tab, evt); } : null, onClick: function (evt) { return onActive(tab, evt); } })); })),
            react_1.default.createElement(button_1.Button, { ref: buttonRef, className: "tea-tabs__backward", type: "icon", icon: vertical ? "arrowup" : "arrowleft", disabled: offset >= 0, onClick: handleBackward }),
            react_1.default.createElement(button_1.Button, { className: "tea-tabs__forward", type: "icon", icon: vertical ? "arrowdown" : "arrowright", disabled: offset <= 0 - getMaxOffset(), onClick: handleForward })),
        react_1.default.createElement("div", { className: "tea-tabs__addons", ref: addonsRef }, addon)));
}
exports.TabBar = TabBar;
//# sourceMappingURL=TabBar.js.map