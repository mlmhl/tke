"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importStar(require("react"));
var classnames_1 = tslib_1.__importDefault(require("classnames"));
var controlled_1 = require("../form/controlled");
var with_statics_1 = require("../_util/with-statics");
var get_precision_1 = require("../_util/get-precision");
var DISABLED_CLS = "is-disabled";
/**
 * 数字输入组件
 */
exports.InputNumber = with_statics_1.withStatics(function InputNumber(props) {
    var _a, _b, _c;
    var style = props.style, unit = props.unit, disabled = props.disabled, className = props.className;
    var _d = useInputNumberHooks(props), minus = _d.minus, input = _d.input, plus = _d.plus;
    var precision = get_precision_1.getPrecision(props.step);
    return (react_1.default.createElement("span", { className: classnames_1.default("tea-inputnum", className, (_a = {},
            _a[DISABLED_CLS] = disabled,
            _a)), style: style },
        react_1.default.createElement("span", { className: classnames_1.default("tea-inputnum__minus", (_b = {},
                _b[DISABLED_CLS] = minus.disabled,
                _b)), onMouseDown: disabled ? function () { return null; } : minus.handleMouseDown }, "-"),
        react_1.default.createElement("input", { className: "tea-input", value: typeof input.value === "number"
                ? input.value.toFixed(precision)
                : input.value, onChange: input.handleChange, onBlur: input.handleBlur, onKeyDown: input.handleKeyDown, disabled: disabled }),
        react_1.default.createElement("span", { className: classnames_1.default("tea-inputnum__plus", (_c = {},
                _c[DISABLED_CLS] = plus.disabled,
                _c)), onMouseDown: disabled ? function () { return null; } : plus.handleMouseDown }, "+"),
        unit && react_1.default.createElement("div", { className: "tea-form__help-text--inline" }, unit)));
}, {
    defaultLabelAlign: "middle",
});
/**
 * InputNumber 状态管理
 */
function useInputNumberHooks(props) {
    var step = props.step;
    var _a = controlled_1.useDefaultValue(props, 0), min = _a.min, max = _a.max, value = _a.value, onChange = _a.onChange;
    var isValidNumber = function (num) {
        return typeof num === "number" && !Number.isNaN(num);
    };
    step = isValidNumber(step) ? step : 1;
    var precision = get_precision_1.getPrecision(step);
    var hasMax = isValidNumber(max);
    var hasMinus = isValidNumber(min);
    var _b = tslib_1.__read(react_1.useState(null), 2), inputValue = _b[0], setInputValue = _b[1];
    var hasInputValue = inputValue !== null;
    var parse = function (newValue) {
        return newValue.trim() === "" ? 0 : parseFloat(newValue);
    };
    var getCurrentValue = function () {
        var currentValue = value;
        if (hasInputValue && /\d/.test(inputValue)) {
            currentValue = parse(inputValue);
            // 解析失败，退回当前值
            if (Number.isNaN(currentValue)) {
                currentValue = value;
            }
        }
        return currentValue;
    };
    var canMinus = function (value) { return !hasMinus || value > min; };
    var canPlus = function (value) { return !hasMax || value < max; };
    var commit = function (_newValue, event) {
        var newValue = _newValue;
        // 从 input 回调过来的，是字符串
        if (typeof newValue === "string") {
            newValue = parse(newValue);
        }
        // 不能小于最小值
        if (hasMinus) {
            newValue = Math.max(min, newValue);
        }
        // 不能大于最大值
        if (hasMax) {
            newValue = Math.min(max, newValue);
        }
        // 解析失败，还原旧值
        if (Number.isNaN(newValue)) {
            newValue = value;
        }
        // 处理精度
        newValue = parse(newValue.toFixed(precision));
        if (typeof onChange === "function") {
            onChange(newValue, { event: event });
        }
        else {
            console.warn("InputNumber 是受控组件，请传入 onChange 属性处理值变化");
        }
    };
    // value 发生变更，清空暂存的值
    react_1.useEffect(function () { return setInputValue(null); }, [value]);
    // 长按增减按钮会持续操作，鼠标抬起，或者组件销毁时要清空
    var autoStepTimer = react_1.useRef(0);
    var clear = function () { return clearTimeout(autoStepTimer.current); };
    react_1.useEffect(function () {
        window.addEventListener("mouseup", clear, true);
        // destroy
        return function () {
            clear();
            window.removeEventListener("mouseup", clear);
        };
    }, []);
    // 为按钮提供步长调整逻辑
    var stepper = function (step) {
        // 步长的符号影响是否允许进行下一步长的判断方法
        var canStep = step > 0 ? canPlus : canMinus;
        return {
            disabled: !canStep(value),
            // 点击按钮的时候，先变更一次。然后，只要鼠标不抬起，自动连续变更
            handleMouseDown: function (evt) {
                var currentValue = getCurrentValue();
                var performStep = function () {
                    if (canStep(currentValue)) {
                        commit((currentValue += step), evt);
                    }
                };
                performStep();
                clear();
                // 1 秒后，开始自动递增
                autoStepTimer.current = setTimeout(function () {
                    var autoPerform = function () {
                        performStep();
                        autoStepTimer.current = setTimeout(autoPerform, 50);
                    };
                    autoPerform();
                }, 700);
                // 保留事件内容，否则在自动步长执行的时候，事件不可用
                evt.persist();
                // 阻止事件变成 blur 事件，导致二次设置
                evt.preventDefault();
            },
        };
    };
    return {
        minus: stepper(-step),
        plus: stepper(step),
        input: {
            value: hasInputValue ? inputValue : value,
            handleChange: function (evt) {
                setInputValue(evt.target.value);
            },
            handleBlur: function (evt) {
                commit(evt.target.value, evt);
                setInputValue(null);
            },
            handleKeyDown: function (evt) {
                var currentValue = getCurrentValue();
                if (canPlus(currentValue) && evt.keyCode === 38) {
                    // ArrowUp
                    evt.preventDefault();
                    commit(currentValue + step, evt);
                }
                else if (canMinus(currentValue) && evt.keyCode === 40) {
                    // ArrowDown
                    evt.preventDefault();
                    commit(currentValue - step, evt);
                }
                // Enter
                if (evt.keyCode === 13) {
                    commit(currentValue, evt);
                    setInputValue(null);
                }
            },
        },
    };
}
//# sourceMappingURL=InputNumber.js.map