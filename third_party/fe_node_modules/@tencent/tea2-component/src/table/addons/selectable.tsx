import React, { useContext } from "react";
import warning from "warning";
import classNames from "classnames";
import { TableAddon, TableProps, RowRenderContext } from "../TableProps";
import { ControlledProps } from "../../form/controlled";
import { CheckTreeRelation, CheckTree } from "../../checktree";
import { Checkbox } from "../../checkbox";
import { getRowKeyFromRecordKey } from "../util/get-row-key-from-record-key";
import { CheckContext } from "../../check";
import { injectPropsIfTargetNotExisted } from "../util/inject-props-if-target-not-existed";
import { useConfig } from "../../_util/config-context";

/**
 * `selectable` 插件用于支持表格可选择行的样式及操作。
 */
export interface SelectableOptions<Record = any>
  extends ControlledProps<
    string[],
    React.SyntheticEvent,
    { event: React.SyntheticEvent; record: Record; selectedRecords: Record[] }
  > {
  /**
   * 不支持非受控模式
   */
  defaultValue?: never;

  /**
   * 提供 `relations` 属性，则会按照树状选择逻辑进行
   */
  relations?: CheckTreeRelation;

  /**
   * 提供 `all` 属性来支持全选
   * 给定字符串可以用作全选项的 `key`
   */
  all?: boolean | string;

  /**
   * 如果开启了全选支持，则可以指定哪些记录从全选的范围内排除
   *
   * - 默认为 `disabled` 可以排除禁用的记录
   * - 提供回调则自定义哪些记录应该排除，对于应该排除的记录，应该返回 `true`
   *
   * @default "disabled"
   */
  shouldRecordExcludeFromAll?: "disabled" | ((record: any) => boolean);

  /**
   * 提供一个列的 `key`，将选择组件插入到一个目标列
   *
   * 默认在最前新建一列插入
   */
  targetColumnKey?: string;

  /**
   * **\[Deprecated\]** 请使用 `indentable` 插件代替
   *
   * @deprecated
   */
  indent?: number;

  /**
   * 是否整行可选
   */
  rowSelect?: boolean;

  /**
   * 列宽度，可以指定 CSS 属性或数字 (单位：px)
   * @default 26
   */
  width?: string | number;

  /**
   * **高级用法**
   * 更改该插件的在每行的渲染内容，`element` 为默认渲染内容，`context` 中包含该行数据相关信息
   * @default x => x
   */
  render?: (
    element: JSX.Element,
    context: RowRenderContext<Record>
  ) => React.ReactNode;

  /**
   * 指定行的选择是否可用
   *
   * **（除展开行外，使用 Table 中的 `rowDisabled`，同样可禁用指定行的选择）**
   *
   * @default () => true
   */
  rowSelectable?: (
    rowKey: string,
    context: { parent: string; children: string[] }
  ) => boolean;
}

export function selectable(options: SelectableOptions): TableAddon {
  const {
    relations = {},
    value,
    onChange,
    all = true,
    targetColumnKey,
    indent,
    rowSelect,
    width = 26,
    render = x => x,
    shouldRecordExcludeFromAll = "disabled",
    rowSelectable = () => true,
  } = options;

  if (typeof indent !== "undefined") {
    warning(
      false,
      "Property `indent` is deprecated. Please use `indentable` addon instead."
    );
  }

  const fallbackColumnKey = "__selectable_addon__";
  const fallbackAllKey = "__selectable_all__";
  const allKey = typeof all === "string" ? all : fallbackAllKey;

  let rowDisabled: TableProps["rowDisabled"] = null;

  return {
    onInjectProps: props => {
      let { columns } = props;

      rowDisabled = props.rowDisabled || (() => false);

      columns = injectPropsIfTargetNotExisted(columns, targetColumnKey, {
        key: fallbackColumnKey,
        width,
        header: null,
        render: () => null,
      });

      return { ...props, columns };
    },
    onInjectColumn: previous => (
      record,
      rowKey,
      recordIndex,
      column,
      columnIndex
    ) => {
      // 不是目标列
      if (column.key !== targetColumnKey && column.key !== fallbackColumnKey) {
        return previous(record, rowKey, recordIndex, column, columnIndex);
      }

      const { children: preChildren, props, ...result } = previous(
        record,
        rowKey,
        recordIndex,
        column,
        columnIndex
      );

      let children = preChildren;

      // 表头
      if (recordIndex === -1) {
        children = (
          <>
            <Checkbox
              style={all ? undefined : { display: "none" }}
              name={allKey}
            >
              {children || <>&nbsp;</>}
            </Checkbox>
            {!all ? children : null}
          </>
        );
      }
      // 记录行
      else {
        let paddingLeft = 0;
        let depth = 0;
        if (indent > 0) {
          let node = rowKey;
          while (relations && relations[node]) {
            depth += 1;
            node = relations[node];
          }
          paddingLeft = indent * depth;
        }

        const checkbox = (
          <TableCheckbox name={rowKey}>{children || <>&nbsp;</>}</TableCheckbox>
        );

        const element = paddingLeft ? (
          <div style={{ paddingLeft }}>{checkbox}</div>
        ) : (
          checkbox
        );

        children = render(element, {
          children: preChildren,
          record,
          depth,
          rowKey,
          recordIndex,
          disabled: rowDisabled(record),
        });
      }
      return { ...result, props, children };
    },
    onInjectTable: renderBody => props => {
      const { recordKey, records, rowDisabled = () => false } = props;
      const rowKey = getRowKeyFromRecordKey(recordKey);

      // 哪些应该从 all 里面排除
      let shouldRecordExcludeFromAllFinal: (record: any) => boolean = null;
      if (typeof shouldRecordExcludeFromAll === "function") {
        shouldRecordExcludeFromAllFinal = shouldRecordExcludeFromAll;
      } else if (shouldRecordExcludeFromAll === "disabled") {
        shouldRecordExcludeFromAllFinal = rowDisabled;
      }
      shouldRecordExcludeFromAllFinal =
        shouldRecordExcludeFromAllFinal || (() => false);

      const relationsKeys = Object.keys(relations);
      const childrenMap = {};

      relationsKeys.forEach(child => {
        const parent = relations[child];
        if (!childrenMap[parent]) {
          childrenMap[parent] = [];
        }
        childrenMap[parent].push(child);
      });

      const disabledKeys = Array.from(
        new Set([...relationsKeys, ...records.map(rowKey)])
      ).filter(
        key =>
          !rowSelectable(key, {
            parent: relations[key],
            children: childrenMap[relations[key]],
          })
      );

      // all keys
      const keys = Array.from(
        new Set([
          ...relationsKeys,
          // 这里 records 不包括扩展行
          ...records
            .filter(x => !shouldRecordExcludeFromAllFinal(x))
            .map(rowKey)
            .filter(x =>
              shouldRecordExcludeFromAll === "disabled"
                ? !disabledKeys.includes(x)
                : true
            ),
        ])
      );

      // keys without children
      const rootKeys = relations ? keys.filter(key => !relations[key]) : keys;

      const relationWithLeafs = {
        ...(relations || {}),
      };

      for (const key of rootKeys) {
        relationWithLeafs[key] = allKey;
      }

      // 只有全选 Check 可用时
      const hasRelations = !!Object.keys(relationWithLeafs).length;

      return (
        <CheckTree
          relations={relationWithLeafs}
          value={value}
          onChange={
            hasRelations
              ? (value, context) =>
                  onChange(value, {
                    ...context,
                    record: records.find(
                      (record, index) =>
                        context.check.name === rowKey(record, index)
                    ),
                    selectedRecords: records.filter((record, index) =>
                      value.includes(rowKey(record, index))
                    ),
                  })
              : null
          }
          disabledNames={[
            ...records.filter(x => rowDisabled(x)).map(rowKey),
            ...disabledKeys,
          ]}
        >
          {renderBody(props)}
        </CheckTree>
      );
    },
    onInjectRow: renderRow => (record, rowKey, recordIndex, columns) => {
      const { prepends, appends, row: preRow } = renderRow(
        record,
        rowKey,
        recordIndex,
        columns
      );

      let row = preRow;

      // 支持整行选择
      row = (
        <SelectWrapper
          key={rowKey}
          name={rowKey}
          rowSelect={rowSelect && !rowDisabled(record)}
        >
          {row}
        </SelectWrapper>
      );

      return { prepends, row, appends };
    },
  };
}

function SelectWrapper({
  name,
  rowSelect,
  children,
  ...props
}: {
  name: string;
  rowSelect: boolean;
  children: React.ReactElement<React.HTMLAttributes<HTMLTableRowElement>>;
} & React.HTMLAttributes<HTMLTableRowElement>): JSX.Element {
  const context = useContext(CheckContext);
  if (context) {
    const checkProps = context.inject({ type: "checkbox", name });
    const { onChange, value } = checkProps;

    const rowSelectProps = {
      onClick: (event: React.MouseEvent<HTMLTableRowElement>) => {
        // 事件合并
        if (typeof props.onClick === "function") {
          props.onClick(event);
        }
        if (typeof children.props.onClick === "function") {
          children.props.onClick(event);
        }

        return onChange(!value, { event, check: checkProps });
      },
    };

    return React.cloneElement(children, {
      ...props,
      className: classNames(props.className, children.props.className, {
        "is-selected": !!value,
      }),
      ...(rowSelect ? rowSelectProps : {}),
    });
  }

  return children;
}

function TableCheckbox({ children, ...props }) {
  const { classPrefix } = useConfig();
  return (
    <Checkbox className={`${classPrefix}-form-check--table-select`} {...props}>
      {children}
    </Checkbox>
  );
}
