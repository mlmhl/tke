import React, { useRef, forwardRef, useState, useEffect, useMemo } from "react";
import classNames from "classnames";
import { ReferenceObject } from "popper.js";
import { ControlledProps, useDefaultValue } from "../form/controlled";
import { Combine, StyledProps } from "../_type";
import { BubbleContent } from "../bubble";
import { Popover } from "../popover";
import { getPrecision } from "../_util/get-precision";
import { useConfig } from "../_util/config-context";

export interface SliderMarkItem {
  /** 值 */
  value: number;

  /** 标记 */
  label?: string;
}

export interface SliderProps
  extends Combine<ControlledProps<number>, StyledProps> {
  /**
   * 最小值
   * @default 0
   */
  min: number;

  /**
   * 最大值
   */
  max: number;

  /**
   * 可选范围
   * @default [min, max]
   */
  range?: [number, number];

  /**
   * 刻度标记
   */
  marks?: SliderMarkItem[];

  /**
   * 步长，必须大于 0，且可被 (max - min) 除尽
   * @default 1
   */
  step?: number;

  /**
   * 是否只能拖拽到刻度上
   * @default false
   */
  markValueOnly?: boolean;

  /**
   * 是否禁用
   * @default false
   */
  disabled?: boolean;

  /**
   * 后置内容
   */
  after?: React.ReactNode;

  /**
   * Bubble 中提示为该函数为返回值，若为 `null` 则隐藏
   * @docType (value: number) => number | string | null
   */
  tipFormatter?: (value: number) => number | string | null;

  /**
   * 滑动过程中 value 更新回调
   */
  onUpdate?: (value: number) => void;

  /**
   * 是否在滑轨上显示提示
   * @default false
   */
  enableTrackTip?: boolean;
}

export function Slider({ min = 0, max, ...props }: SliderProps) {
  const { classPrefix } = useConfig();
  // eslint-disable-next-line react/destructuring-assignment
  const allowedRange = Array.isArray(props.range) ? props.range : [min, max];

  if (typeof allowedRange[0] !== "number" || allowedRange[0] < min) {
    allowedRange[0] = min;
  }
  if (typeof allowedRange[1] !== "number" || allowedRange[1] > max) {
    allowedRange[1] = max;
  }

  const {
    style,
    className,
    value,
    onChange,
    step = 1,
    marks = [],
    after,
    disabled,
    markValueOnly,
    enableTrackTip = false,
    tipFormatter = number => number,
    onUpdate = () => null,
  } = useDefaultValue(props, allowedRange[0] || 0);

  const precision = useMemo(() => getPrecision(step), [step]);

  const [interactiveValue, setInteractiveValue] = useState(null);

  const range = Math.abs(max - min);
  const proportionValue = interactiveValue === null ? value : interactiveValue;
  const proportion = ((proportionValue - min) / range) * 100;

  // 定位相关 hooks
  const startRef = useRef<HTMLElement>(null);
  const endRef = useRef<HTMLElement>(null);

  // 滑轨相关 hooks
  const scheduleRef = useRef(null);
  const mouseElement = useRef<
    ReferenceObject & { scrollTop: number; scrollLeft: number }
  >(null);
  const [mousePosition, setMousePosition] = useState<number>(null);

  // 滑块相关 hooks
  const positionRef = useRef<number>(0);
  const dragOffsetRef = useRef<number>(0);
  const innerScheduleRef = useRef(null);
  const [dragging, setDragging] = useState(false);
  const [hovering, setHovering] = useState(false);

  useEffect(() => removeDocumentEvents, []); // eslint-disable-line react-hooks/exhaustive-deps

  function addDocumentMouseEvents() {
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
  }

  function removeDocumentEvents() {
    document.removeEventListener("mousemove", handleMouseMove);
    document.removeEventListener("mouseup", handleMouseUp);
  }

  function handleMouseUp() {
    setDragging(false);
    removeDocumentEvents();
    const value = getValueByPosition(positionRef.current);
    onChange(value, { event: null });
    setInteractiveValue(null);
  }

  function handleMouseMove(event: MouseEvent) {
    if (disabled) {
      return;
    }
    const position = event.pageX;
    const value = getValueByPosition(position - dragOffsetRef.current);

    if (getValueByPosition(positionRef.current) !== value) {
      positionRef.current = position;
      setInteractiveValue(value);
      onUpdate(value);
    }

    if (innerScheduleRef.current) {
      innerScheduleRef.current();
    }
  }

  function handleMouseDown(event: React.MouseEvent) {
    if (disabled) {
      return;
    }
    const coords = event.currentTarget.getBoundingClientRect();
    const position = window.pageXOffset + coords.left + coords.width * 0.5;
    dragOffsetRef.current = event.pageX - position;
    positionRef.current = position;
    setDragging(true);
    removeDocumentEvents();
    addDocumentMouseEvents();
  }

  function getStartPos(): number {
    if (!startRef.current) {
      return 0;
    }
    const coords = startRef.current.getBoundingClientRect();
    return window.pageXOffset + coords.left;
  }

  function getEndPos(): number {
    if (!endRef.current) {
      return 0;
    }
    const coords = endRef.current.getBoundingClientRect();
    return window.pageXOffset + coords.left;
  }

  function getValueByPosition(position: number) {
    const [start, end] = [getStartPos(), getEndPos()];
    const posRange = end - start;
    if (position < start) {
      position = start; // eslint-disable-line no-param-reassign
    }
    if (position > end) {
      position = end; // eslint-disable-line no-param-reassign
    }
    const proportion = (position - start) / posRange;
    return getValueByProportion(proportion);
  }

  function getValueByProportion(proportion: number): number {
    const pow = 10 ** precision;
    let value = proportion * range;
    value -= ((value * pow) % (step * pow)) / pow;
    value += min;

    if (markValueOnly && marks.length) {
      // eslint-disable-next-line prefer-destructuring
      value = marks.reduce(
        (prev, cur) =>
          Math.abs(cur.value - value) < Math.abs(prev.value - value)
            ? cur
            : prev,
        marks[0]
      ).value;
    }

    const [allowedStart, allowedEnd] = allowedRange;
    if (value < allowedStart) {
      value = allowedStart;
    }
    if (value > allowedEnd) {
      value = allowedEnd;
    }
    return parseFloat(value.toFixed(precision));
  }

  function handleMouseDownOnBar(event: React.MouseEvent) {
    if (disabled) {
      return;
    }
    const position = event.pageX;
    const value = getValueByPosition(position);
    setInteractiveValue(value);
    onUpdate(value);

    // 滑块拖动相关事件
    setDragging(true);
    positionRef.current = position;
    dragOffsetRef.current = 0;
    removeDocumentEvents();
    addDocumentMouseEvents();
  }

  function handleMouseMoveForPopover(event: React.MouseEvent) {
    if (disabled) {
      return;
    }
    const position = event.pageX;
    setMousePosition(position);
    setMouseElement(event.nativeEvent);
    if (scheduleRef.current) {
      scheduleRef.current();
    }
  }

  function setMouseElement(event: MouseEvent) {
    const clientX = Math.round(event.clientX);
    const clientY = startRef.current.getBoundingClientRect().top;
    mouseElement.current = {
      clientWidth: 0,
      clientHeight: 0,
      getBoundingClientRect: () => ({
        left: clientX,
        top: clientY,
        right: clientX,
        bottom: clientY,
        width: 0,
        height: 0,
      }),
      // IE10 下 Popper 读取这两个值计算
      scrollTop: 0,
      scrollLeft: 0,
    };
  }

  return (
    <div
      className={classNames(`${classPrefix}-slider`, className, {
        "is-disabled": disabled,
      })}
      style={style}
    >
      <Popover
        visible={
          enableTrackTip &&
          !disabled &&
          !hovering &&
          !dragging &&
          !!mousePosition
        }
        referenceElement={mouseElement.current}
        overlayStyle={{
          pointerEvents: "none",
        }}
        overlay={({ placement, scheduleUpdate }) => {
          scheduleRef.current = scheduleUpdate;
          const tips = tipFormatter(getValueByPosition(mousePosition));
          return (
            tips !== null && (
              <BubbleContent placement={placement}>{tips}</BubbleContent>
            )
          );
        }}
      >
        <div
          className={`${classPrefix}-slider__content`}
          onMouseDown={handleMouseDownOnBar}
          onMouseMove={handleMouseMoveForPopover}
          onMouseLeave={() => setMousePosition(null)}
          onDragStart={e => e.preventDefault()}
        >
          <StartFlag ref={startRef} />

          {/* 滑轨 */}
          <div className={`${classPrefix}-slider__bar`}>
            <div
              className={`${classPrefix}-slider__track`}
              style={{ width: `${proportion}%` }}
            />
          </div>

          {/* 滑块 */}
          <Popover
            visible={dragging || hovering}
            overlayStyle={{
              pointerEvents: "none",
            }}
            overlay={({ placement, scheduleUpdate }) => {
              innerScheduleRef.current = scheduleUpdate;
              const tips = tipFormatter(proportionValue);
              return (
                tips !== null && (
                  <BubbleContent placement={placement}>{tips}</BubbleContent>
                )
              );
            }}
          >
            <div
              className={`${classPrefix}-slider__handle`}
              style={{ left: `${proportion}%` }}
              onMouseDown={handleMouseDown}
              onMouseEnter={() => setHovering(true)}
              onMouseLeave={() => setHovering(false)}
              onClick={e => e.stopPropagation()}
              onMouseMove={e => e.stopPropagation()}
            >
              <span className={`${classPrefix}-slider__handle-inner`} />
            </div>
          </Popover>

          {/* 标尺 */}
          <div className={`${classPrefix}-slider__mark`}>
            {marks
              .filter(({ value }) => value >= min && value <= max)
              .map(({ value, label }) => (
                <span
                  key={value}
                  className={`${classPrefix}-slider__text`}
                  style={{
                    left: `${((value - min) / range) * 100}%`,
                    userSelect: "none",
                  }}
                >
                  {label || value}
                </span>
              ))}
          </div>

          <EndFlag ref={endRef} />
        </div>
      </Popover>
      <div className={`${classPrefix}-slider__extend`}>{after}</div>
    </div>
  );
}

const StartFlag = forwardRef<HTMLElement>((_, ref) => (
  <span
    ref={ref}
    style={{ left: 0, position: "absolute", visibility: "hidden" }}
  />
));

const EndFlag = forwardRef<HTMLElement>((_, ref) => (
  <span
    ref={ref}
    style={{ left: "100%", position: "absolute", visibility: "hidden" }}
  />
));
