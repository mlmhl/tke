import React, {
  useState,
  Fragment,
  useRef,
  useEffect,
  useCallback,
} from "react";
import { ListOnScrollProps } from "react-window";
import { Popover, TriggerProps } from "../popover";
import { DropdownBox, CommonDropdownProps } from "../dropdown";
import { StyledProps, Combine } from "../_type";
import { SelectOptionWithGroup } from "../select";
import {
  VirtualizedList as List,
  VirtualizedListItem,
} from "../list/VirtualizedList";
import { ControlledProps, useDefaultValue } from "../form";
import { Text } from "../text";
import { EmptyTip } from "../tips";
import { useDefault } from "../_util/use-default";
import { KeyCode } from "../_util/key-code";

export interface AutoCompleteProps
  extends Combine<CommonDropdownProps, StyledProps, ControlledProps<string>> {
  /**
   * 下拉选项列表
   */
  options?: SelectOptionWithGroup[];

  /**
   * 分组
   */
  groups?: {
    [groupKey: string]: React.ReactNode;
  };

  /**
   * `options` 为空时展示，可使用字符串或 [StatusTip](/component/tips) 相关组件
   */
  tips?: React.ReactNode;

  /**
   * 展示为高亮的关键词
   */
  keyword?: string;

  /**
   * 要包裹的输入组件
   */
  children?: (
    ref: React.Ref<HTMLInputElement | HTMLTextAreaElement>,
    context: { close: () => void }
  ) => React.ReactNode;

  /**
   * `options` 滚动至底部的回调
   */
  onScrollBottom?: (props: ListOnScrollProps) => void;
}

function highlight(text: React.ReactNode, keyword: string): React.ReactNode {
  if (typeof text !== "string") {
    return text;
  }
  return text.split(keyword).map((text, index) => {
    const key = `${text}-${index}`;
    if (index >= 1) {
      return (
        <Fragment key={key}>
          <strong>{keyword}</strong>
          {text}
        </Fragment>
      );
    }
    return <Text key={key}>{text}</Text>;
  });
}

export function AutoComplete(props: AutoCompleteProps) {
  const {
    className,
    style = {},
    onChange,
    children,
    options = [],
    groups = {},
    keyword,
    onScrollBottom,
    closeOnScroll = true,
    open,
    defaultOpen,
    onOpenChange,
    ...popoverProps
  } = useDefaultValue(props);
  const [isSelected, setIsSelected] = useState<boolean>(false);
  const inputRef = useRef<HTMLElement>(null);
  const [isOpened, setIsOpened] = useDefault(open, defaultOpen, onOpenChange);
  const [dropdownWidth, setDropdownWidth] = useState<number>(undefined);
  const [currentIndex, setCurrentIndex] = useState<number>(0);
  const listRef = useRef(null);

  const hasGroup = !!options.find(opt => !!opt.groupKey);

  let { tips = <EmptyTip /> } = props;
  if (options.length === 0) {
    tips = typeof tips === "string" ? <EmptyTip emptyText={tips} /> : tips;
  } else {
    tips = null;
  }

  const items = getListItems({
    tips,
    groups,
    options,
  });
  const count = items.length;

  const getOptionIndex = useCallback(
    (current: number, step: number = 1) => {
      let flag = 1;
      let index = (current + step + count) % count;
      let item = items[index % count];
      while (flag < count && !item.option) {
        flag += 1;
        index = (index + step + count) % count;
        item = items[index % count];
      }
      return index;
    },
    [items, count]
  );

  useEffect(() => {
    if (!inputRef.current) return null;
    function handleKeyDown(event: KeyboardEvent) {
      const { option } = items[currentIndex % count] || {};

      switch (event.keyCode) {
        case KeyCode.Up:
          event.preventDefault();
          setCurrentIndex(c => {
            const index = getOptionIndex(c, -1);
            if (listRef.current) {
              listRef.current.scrollToItem(index);
            }
            return index;
          });
          break;
        case KeyCode.Down:
          event.preventDefault();
          setCurrentIndex(c => {
            const index = getOptionIndex(c);
            if (listRef.current) {
              listRef.current.scrollToItem(index);
            }
            return index;
          });
          break;
        case KeyCode.Enter:
          if (isOpened && option) {
            if (option.disabled) break;
            setIsOpened(false);
            onChange(option.value, { event: event as any });
          }
          break;
        case KeyCode.Esc:
          setIsOpened(false);
          inputRef.current.blur();
          break;
        default:
          setCurrentIndex(0);
          break;
      }
    }
    inputRef.current.addEventListener("keydown", handleKeyDown);
    return () => {
      inputRef.current.removeEventListener("keydown", handleKeyDown);
    };
  }, [
    currentIndex,
    inputRef,
    isOpened,
    onChange,
    options,
    setIsOpened,
    items,
    count,
    getOptionIndex,
  ]);

  const boxStyle = { width: dropdownWidth, ...style };

  return (
    <Popover
      escapeWithReference
      animationScaleFrom={1}
      transitionTimeout={{ enter: 0, exit: 0 }}
      trigger={[AutoCompleteTrigger, { setIsSelected }]}
      placement="bottom-start"
      visible={isOpened && !isSelected}
      onVisibleChange={setIsOpened}
      placementOffset={5}
      closeOnScroll={closeOnScroll}
      {...popoverProps}
      overlay={
        <DropdownBox className={className} style={boxStyle}>
          <List
            containerStyle={boxStyle}
            containerClassName={className}
            virtualizedRef={listRef}
            type={hasGroup ? "option-group" : "option"}
            items={items.map((item, index) => {
              if (item.type === "option") {
                const { option } = item;
                return {
                  ...item,
                  props: {
                    disabled: option.disabled,
                    current: currentIndex % count === index,
                    onClick: event => {
                      event.stopPropagation();
                      inputRef.current.focus();
                      onChange(option.value, { event });
                      setIsSelected(true);
                      setCurrentIndex(index);
                    },
                    tooltip: option.tooltip,
                  },
                };
              }
              return item;
            })}
            onScrollBottom={onScrollBottom}
          />
        </DropdownBox>
      }
    >
      {children(
        dom => {
          inputRef.current = dom;
          if (dom) {
            setDropdownWidth(dom.offsetWidth);
          }
        },
        { close: () => setIsOpened(false) }
      )}
    </Popover>
  );
}

export function AutoCompleteTrigger({
  visible,
  setVisible,
  openDelay = 0,
  closeDelay = 0,
  render,
  setIsSelected,
}: TriggerProps & { setIsSelected: (s: boolean) => void }) {
  const commonProps = {
    onFocus: () => setVisible(true, openDelay),
    onChange: () => {
      setIsSelected(false);
      if (!visible) {
        setVisible(true, openDelay);
      }
    },
    onClick: () => {
      setIsSelected(false);
      if (!visible) {
        setVisible(true, openDelay);
      }
    },
    onBlur: () => setVisible(false, closeDelay),
  };
  return render({
    overlayProps: { ...commonProps, tabIndex: 1000 },
    childrenProps: commonProps,
  });
}

AutoComplete.defaultLabelAlign = "middle";

function getListItems({
  tips,
  options,
  groups,
}: Pick<AutoCompleteProps, "tips" | "options" | "groups">): VirtualizedListItem<
  SelectOptionWithGroup
>[] {
  const items: VirtualizedListItem<SelectOptionWithGroup>[] = [];
  // tips
  if (tips) {
    items.push({ type: "tips", key: "__auto_complete_tips", text: tips });
  }
  options.forEach((option, index) => {
    if (
      option.groupKey &&
      (index === 0 || option.groupKey !== options[index - 1].groupKey)
    ) {
      items.push({
        type: "group",
        key: `${option.groupKey}-${option.value}`,
        text: groups[option.groupKey],
      });
    }
    items.push({
      type: "option",
      key: option.value,
      text: typeof option.text === "undefined" ? option.value : option.text,
      option,
    });
  });
  return items;
}
