/* eslint-disable */
import React from "react";
import classNames from "classnames";
import clone from "clone";
import { Tag, TagValue } from "./Tag";
import { TagInput } from "./TagInput";
import { AttributeValue } from "./AttributeSelect";
import { withOutsideClick } from "../_util/with-outside-click";
import { withTranslation, WithTranslationProps } from "../i18n";
import { Bubble } from "../bubble";
import { Modal } from "../modal";
import { StyledProps, Combine } from "../_type";
import { TagSearchBoxContext } from "./TagSearchBoxContext";
import { Button } from "../button";
import { withConfig, WithConfigProps } from "../util";

const noop = () => {};

export interface TagSearchBoxProps
  extends Combine<StyledProps, WithTranslationProps, WithConfigProps> {
  /**
   * è¦é€‰æ‹©è¿‡æ»¤çš„èµ„æºå±æ€§çš„é›†åˆ
   */
  attributes?: AttributeValue[];

  /**
   * æœç´¢æ¡†ä¸­é»˜è®¤åŒ…å«çš„æ ‡ç­¾å€¼çš„é›†åˆ
   */
  defaultValue?: TagValue[];

  /**
   * é…åˆ onChange ä½œä¸ºå—æ§ç»„ä»¶ä½¿ç”¨
   */
  value?: TagValue[];

  /**
   * æœç´¢æ¡†æ”¶èµ·åå®½åº¦
   * @default 210
   */
  minWidth?: string | number;

  /**
   * å½“æ–°å¢/ä¿®æ”¹/å‡å°‘æ ‡ç­¾æ—¶è°ƒç”¨æ­¤å‡½æ•°
   *
   * **ğŸ’¡ ç”¨äºè§¦å‘æœç´¢**
   */
  onChange?: (tags: TagValue[]) => void;

  /**
   * æœç´¢æ¡†ä¸­æç¤ºè¯­
   *
   * @default "å¤šä¸ªå…³é”®å­—ç”¨ç«–çº¿ â€œ|â€ åˆ†éš”ï¼Œå¤šä¸ªè¿‡æ»¤æ ‡ç­¾ç”¨å›è½¦é”®åˆ†éš”" ï¼ˆå·²å¤„ç†å›½é™…åŒ–ï¼‰
   */
  tips?: string;

  /**
   * èµ„æºå±æ€§é€‰æ‹©ä¸‹æ‹‰æ¡†æç¤º
   *
   * @default "é€‰æ‹©èµ„æºå±æ€§è¿›è¡Œè¿‡æ»¤" ï¼ˆå·²å¤„ç†å›½é™…åŒ–ï¼‰
   */
  attributesSelectTips?: string;

  /**
   * éšè—å¸®åŠ©æŒ‰é’®
   *
   * @default false
   */
  hideHelp?: boolean;

  /**
   * æ¸…ç©ºæŒ‰é’®ç‚¹å‡»å›è°ƒ
   *
   * @version 2.2.2
   */
  onClearButtonClick?: (e: React.MouseEvent) => void;

  /**
   * å¸®åŠ©æŒ‰é’®ç‚¹å‡»å›è°ƒ
   *
   * è¿”å› `false` é˜»æ­¢é»˜è®¤æç¤ºè¡Œä¸º
   *
   * @version 2.2.2
   */
  onHelpButtonClick?: (e: React.MouseEvent) => void | false;

  /**
   * æœç´¢æŒ‰é’®ç‚¹å‡»å›è°ƒ
   *
   * @version 2.2.2
   */
  onSearchButtonClick?: (e: React.MouseEvent, value: TagValue[]) => void;
}

export interface TagSearchBoxState {
  /**
   * æœç´¢æ¡†æ˜¯å¦ä¸ºå±•å¼€çŠ¶æ€
   */
  active: boolean;

  /**
   * æ˜¯å¦å±•ç¤ºæç¤ºæ¡†
   */
  dialogActive: boolean;

  /**
   * å½“å‰å…‰æ ‡ä½ç½®
   */
  curPos: number;

  /**
   * å½“å‰å…‰æ ‡ï¼ˆç„¦ç‚¹ï¼‰æ‰€åœ¨ä½ç½®çš„å…ƒç´ ç±»å‹
   */
  curPosType: FocusPosType;

  /**
   * æ˜¯å¦å±•ç¤ºå€¼é€‰æ‹©ç»„ä»¶
   */
  showSelect: boolean;

  /**
   * å·²é€‰æ ‡ç­¾
   */
  tags: TagValue[];
}

/**
 * ç„¦ç‚¹æ‰€åœ¨ä½ç½®ç±»å‹
 */
export enum FocusPosType {
  INPUT,
  INPUT_EDIT,
  TAG,
}

let COUNTER = 0;

@withConfig
@withTranslation
@withOutsideClick("close")
export class TagSearchBox extends React.Component<
  TagSearchBoxProps,
  TagSearchBoxState
> {
  state: TagSearchBoxState = {
    active: false,
    dialogActive: false,
    curPos: 0,
    curPosType: FocusPosType.INPUT,
    showSelect: true,
    tags: this.props.defaultValue
      ? this.props.defaultValue.map(item => {
          item["_key"] = COUNTER++;
          return item;
        })
      : [],
  };

  componentDidMount() {
    this.resetTagsState(this.props);
  }

  componentWillReceiveProps(nextProps: TagSearchBoxProps) {
    this.resetTagsState(nextProps);
  }

  resetTagsState = (props: TagSearchBoxProps, callback?: Function) => {
    if ("value" in props) {
      const value = props.value.map(item => {
        if (!("_key" in item)) {
          item["_key"] = COUNTER++;
        }
        return item;
      });
      this.setState({ tags: clone(value) }, () => {
        callback && callback();
      });
    }
  };

  open = () => {
    const { active, tags } = this.state;
    if (!active) {
      this.setState({ active: true });
      // å±•å¼€æ—¶ä¸æ¿€æ´» select æ˜¾ç¤º
      this.setState({ curPosType: FocusPosType.INPUT, curPos: tags.length });
    } else {
      this.handleTagEvent("click-input", tags.length);
    }
    this.setState({ showSelect: true });
    setTimeout(() => {
      this[`tag-${tags.length}`].moveToEnd();
    }, 100);
  };

  close = () => {
    // ç¼–è¾‘æœªå®Œæˆçš„å–æ¶ˆç¼–è¾‘
    const tags = this.state.tags.map((item, index) => {
      if (item["_edit"]) {
        this[`tag-${index}`].editDone();
        item["_edit"] = false;
      }
      return item;
    });

    this.setTags(
      tags,
      () => {
        this.setState({ showSelect: false });
        if (this.state.active) {
          this.setState({ curPos: -1 }, () =>
            this.setState({ active: false }, () => {
              if (this[`search-box`]) {
                this[`search-box`].scrollLeft = 0;
              }
            })
          );
        }
      },
      false
    );
  };

  getValue = (tags: TagValue[]): TagValue[] => {
    const result = [];
    tags.forEach(item => {
      const { values, attr = null } = item;
      if (values.length > 0) {
        result.push({ attr, values, _key: item["_key"], _edit: item["_edit"] });
      }
    });
    return result;
  };

  notify = (tags: TagValue[]) => {
    const { onChange = noop } = this.props;
    onChange(this.getValue(tags));
  };

  // Tags å‘ç”Ÿå˜åŠ¨
  setTags(tags: TagValue[], callback?: Function, notify = true): void {
    const cb = () => {
      notify && this.notify(tags);
      callback && callback();
    };
    // å—æ§æ¨¡å¼
    if (notify && this.props.value) {
      this.resetTagsState(this.props, cb);
    } else {
      this.setState({ tags }, cb);
    }
  }

  /**
   * ç‚¹å‡»æ¸…é™¤æŒ‰é’®è§¦å‘äº‹ä»¶
   */
  handleClear = (e: React.MouseEvent): void => {
    e.stopPropagation();

    const { onClearButtonClick = noop } = this.props;
    onClearButtonClick(e);

    const { tags } = this.state;
    const nextTags = tags.filter(i => i.attr && i.attr.removeable === false);
    const index = `tag-${nextTags.length}`;

    if (tags.length <= 0) {
      this[index].setInputValue("");
      return;
    }

    this.setTags(nextTags, () =>
      setTimeout(() => {
        this[index].setInputValue("");
        this[index].focusInput();
      }, 0)
    );
    this.setState({ curPos: 0, curPosType: FocusPosType.INPUT });
    // åˆ·æ–°ä¸‹æ‹‰åˆ—è¡¨ä½ç½®
    const input = this[`tag-${tags.length}`];
    if (input) {
      input.scheduleUpdate();
    }
  };

  /**
   * ç‚¹å‡»å¸®åŠ©è§¦å‘äº‹ä»¶
   */
  handleHelp = e => {
    e.stopPropagation();

    const { onHelpButtonClick = noop } = this.props;
    if (onHelpButtonClick(e) === false) {
      return;
    }

    this.setState({ dialogActive: true });
  };

  /**
   * ç‚¹å‡»æœç´¢è§¦å‘äº‹ä»¶
   */
  handleSearch = e => {
    if (!this.state.active) {
      // å¦‚æœç›‘å¬äº†æŒ‰é’®ç‚¹å‡»ï¼Œæ­¤æ—¶ç‚¹å‡»æŒ‰é’®ä¸æ¿€æ´»æœç´¢æ¡†
      if ("onSearchButtonClick" in this.props) {
        e.stopPropagation();
        this.props.onSearchButtonClick(e, this.getValue(this.state.tags));
      }
      return;
    }

    e.stopPropagation();

    // è¾“å…¥å€¼ç”Ÿæˆæ ‡ç­¾æ“ä½œä¼šå¼‚æ­¥æ”¹å˜ tags
    // æ­¤å¤„ä¿è¯ tags çŠ¶æ€å˜åŒ–å®Œæˆåå†è¿›è¡Œå›è°ƒ
    setTimeout(() => {
      const { onSearchButtonClick = noop } = this.props;
      onSearchButtonClick(e, this.getValue(this.state.tags));
    }, 100);

    const { curPos, curPosType, tags } = this.state;
    let flag = false;

    const input = this[`tag-${tags.length}`];
    if (input && input.addTagByInputValue) {
      if (input.addTagByInputValue()) {
        flag = true;
      }
    }

    for (let i = 0; i < tags.length; ++i) {
      if (!this[`tag-${i}`] || !this[`tag-${i}`].addTagByEditInputValue) return;
      if (tags[i]["_edit"] && this[`tag-${i}`].addTagByEditInputValue())
        flag = true;
    }

    if (flag) return;

    this.notify(this.state.tags);
    input.focusInput();
  };

  /**
   *  å¤„ç†Tagç›¸å…³äº‹ä»¶
   */
  handleTagEvent = (type: string, index: number, payload?: any): void => {
    const { tags, active } = this.state;

    switch (type) {
      case "add":
        payload["_key"] = COUNTER++;
        tags.splice(++index, 0, payload);
        this.setTags(tags, () => {
          if (this[`tag-${index}`]) {
            this[`tag-${index}`].focusInput();
          }
        });
        this.setState({ showSelect: false });
        break;

      case "edit":
        this[`tag-${index}`].editDone();
        tags[index].attr = payload.attr;
        tags[index].values = payload.values;
        tags[index]["_edit"] = false;

        this.setTags(tags);
        index++;
        this.setState({ showSelect: false, curPosType: FocusPosType.INPUT });
        break;

      case "edit-cancel":
        this[`tag-${index}`].editDone();

        this.setTags(tags, () => null, false);
        this.setState({ showSelect: false, curPosType: FocusPosType.INPUT });
        break;

      case "editing":
        if ("attr" in payload && tags[index]) tags[index].attr = payload.attr;
        if ("values" in payload && tags[index])
          tags[index].values = payload.values;
        this.setTags(tags, null, false);
        break;

      case "del":
        if (payload === "keyboard") index--;
        if (!tags[index]) break;

        // æ£€æŸ¥ä¸å¯ç§»é™¤
        const { attr } = tags[index];
        if (attr && "removeable" in attr && attr.removeable === false) {
          break;
        }

        tags.splice(index, 1);
        this.setTags(tags, () => {
          this.setState({ curPosType: FocusPosType.INPUT });
        });
        if (payload !== "edit") {
          this.setState({ showSelect: false });
        }
        break;

      // payload ä¸ºç‚¹å‡»ä½ç½®
      case "click":
        if (!active) {
          this.open();
          return;
        }
        // è§¦å‘ä¿®æ”¹
        const pos = payload;
        tags[index]["_edit"] = true;
        this.setTags(
          tags,
          () => {
            this.setState({ showSelect: true }, () => {
              this[`tag-${index}`].edit(pos);
            });
          },
          false
        );

        this.setState({ curPosType: FocusPosType.INPUT_EDIT });
        break;

      case "click-input":
        if (payload === "edit") {
          this.setState({ curPosType: FocusPosType.INPUT_EDIT });
        } else {
          this.setState({ curPosType: FocusPosType.INPUT });
        }

        if (!active) {
          this.setState({ active: true });
        }
        this.setState({ showSelect: true });
        break;
    }

    this.setState({ curPos: index });
  };

  render() {
    const {
      active,
      tags,
      curPos,
      curPosType,
      dialogActive,
      showSelect,
    } = this.state;
    const {
      t,
      config: { classPrefix },
      className,
      style = {},
      minWidth = 210,
      attributes,
      hideHelp,
      tips = t.tagSearchBoxTips,
      attributesSelectTips = t.tagSearchBoxSelectTitle,
    } = this.props;

    // ç”¨äºè®¡ç®— focused åŠ isFocused, åˆ¤æ–­æ˜¯å¦æ˜¾ç¤ºé€‰æ‹©ç»„ä»¶
    // (ç›´æ¥ä½¿ç”¨ Input ç»„ä»¶å†…éƒ¨ onBlur åˆ¤æ–­ä¼šä½¿å¾— click æ—¶ç»„ä»¶æ¶ˆå¤±)
    let focusedInputIndex = -1;
    if (
      curPosType === FocusPosType.INPUT ||
      curPosType === FocusPosType.INPUT_EDIT
    ) {
      focusedInputIndex = curPos;
    }

    const tagList = tags.map((item, index) => {
      // è¡¥å…¨ attr å±æ€§
      attributes.forEach(attrItem => {
        if (item.attr && attrItem.key && attrItem.key == item.attr.key) {
          item.attr = Object.assign({}, item.attr, attrItem);
        }
      });

      const selectedAttrKeys = [];
      tags.forEach(tag => {
        if (
          tag.attr &&
          item.attr &&
          item["_edit"] &&
          item.attr.key === tag.attr.key
        )
          return null;
        if (tag.attr && tag.attr.key && !tag.attr.reusable) {
          selectedAttrKeys.push(tag.attr.key);
        }
      });

      const useableAttributes = attributes.filter(
        item => selectedAttrKeys.indexOf(item.key) < 0
      );

      return (
        <Tag
          ref={tag => (this[`tag-${index}`] = tag)}
          active={active}
          key={item["_key"]}
          attributes={useableAttributes}
          attr={item.attr}
          values={item.values}
          maxWidth={
            this["search-wrap"] ? this["search-wrap"].clientWidth : null
          }
          focused={
            focusedInputIndex === index && showSelect ? curPosType : null
          }
          dispatchTagEvent={(type, payload) =>
            this.handleTagEvent(type, index, payload)
          }
        />
      );
    });

    const selectedAttrKeys = tags
      .map(item => (item.attr && !item.attr.reusable ? item.attr.key : null))
      .filter(item => !!item);
    const useableAttributes = attributes.filter(
      item => selectedAttrKeys.indexOf(item.key) < 0
    );

    tagList.push(
      <TagInput
        key="__input__"
        ref={input => (this[`tag-${tags.length}`] = input)}
        active={active}
        maxWidth={this["search-wrap"] ? this["search-wrap"].clientWidth : null}
        attributes={useableAttributes}
        isFocused={focusedInputIndex === tags.length && showSelect}
        dispatchTagEvent={(type, payload) =>
          this.handleTagEvent(type, tags.length, payload)
        }
      />
    );

    return (
      <div
        className={classNames(
          `${classPrefix}-search ${classPrefix}-search--tags`,
          className,
          {
            "is-active": active,
          }
        )}
        ref={div => (this["search-wrap"] = div)}
        style={active ? style : { ...style, width: minWidth }}
      >
        <div
          className={`${classPrefix}-search__inner`}
          onClick={this.open}
          ref={div => (this[`search-box`] = div)}
          style={{ cursor: "text" }}
        >
          <div className={`${classPrefix}-tag-group`}>
            <TagSearchBoxContext.Provider value={{ attributesSelectTips }}>
              {tagList}
            </TagSearchBoxContext.Provider>
          </div>

          <div
            className={`${classPrefix}-text-weak ${classPrefix}-search__tips`}
            style={{ position: "relative" }}
          >
            {tips}
          </div>
          {/* æ¸…é™¤æŒ‰é’®æ ¹æ® hideHelp æ·»åŠ ç±»åç¡®å®šä½ç½® */}
          {!!active && tags.length > 0 && (
            <Bubble content={t.cleanText}>
              <Button
                htmlType="button"
                type="icon"
                icon="dismiss"
                className={classNames({
                  [`${classPrefix}-btn--dismiss`]: !hideHelp,
                  [`${classPrefix}-btn--info`]: !!hideHelp,
                })}
                onClick={this.handleClear}
              />
            </Bubble>
          )}
          {!!active && !hideHelp && (
            <Bubble content={t.helpText}>
              <Button
                htmlType="button"
                type="icon"
                icon="info"
                className={`${classPrefix}-btn--info`}
                onClick={this.handleHelp}
              />
            </Bubble>
          )}
          <Bubble content={active ? t.searchText : null}>
            <Button
              htmlType="button"
              type="icon"
              icon="search"
              className={`${classPrefix}-btn--search`}
              onClick={this.handleSearch}
            />
          </Bubble>
        </div>

        <Modal
          visible={dialogActive}
          size="auto"
          caption={t.helpText}
          onClose={() => this.setState({ dialogActive: false })}
          className="ignore-outside-click"
        >
          <Modal.Body>
            <i
              style={{
                width: 910,
                height: 476,
                backgroundImage: `url(${t.tagSearchBoxHelpImgUrl})`,
                backgroundSize: "contain",
                backgroundRepeat: "no-repeat",
                backgroundPosition: "center",
                display: "inline-block",
              }}
            />
          </Modal.Body>
        </Modal>
      </div>
    );
  }
}
