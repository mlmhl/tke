import React, { useState, useEffect, useRef, useCallback } from "react";
import classNames from "classnames";
import moment, { Moment, isMoment } from "moment";
import { ControlledProps, useDefaultValue } from "../form/controlled";
import CalendarPart from "../calendar/CalendarPart";
import { CalendarTable, getTimeRange } from "../calendar/CalendarTable";
import { Combine } from "../_type";
import { TimeSupportWrapper } from "./TimeSupportWrapper";
import { Input } from "../input/Input";
import { useTranslation } from "../i18n";
import { CommonDatePickerProps } from "./DatePickerProps";
import { getYearMonthDate, DatePickerTrigger } from "./util";
import { getHourMinuteSecond, getValidTimeValue } from "../timepicker/util";
import { TimeDisabledProps } from "../timepicker/TimeProps";
import { DropdownBox } from "../dropdown";
import {
  RangeDateType,
  showTimeType,
  CalendarTableType,
  DateChangeContext,
} from "../calendar/DateProps";
import { withStatics } from "../_util/with-statics";
import { useDefault } from "../_util/use-default";
import { Popover } from "../popover/Popover";
import { useConfig } from "../_util/config-context";
import { Icon } from "../icon";
import { noop } from "../_util/noop";

export interface RangePickerProps
  extends Combine<CommonDatePickerProps, ControlledProps<RangeDateType>> {
  /**
   * 分隔符
   * @default ~
   */
  separator?: string;

  /**
   * 是否开启时间选择，可传递对象设定时间选择配置
   */
  showTime?: showTimeType<RangeDateType>;

  /**
   * 不可选的日期
   */
  disabledDate?: (date: Moment, startDate?: Moment) => boolean;

  /**
   * 不可选的时间
   */
  disabledTime?: (
    dates: RangeDateType,
    partial: "start" | "end"
  ) => TimeDisabledProps;
}

const getFormat = showTime => (showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD");

export function isValidRangeValue(value: any) {
  return Array.isArray(value) && isMoment(value[0]) && isMoment(value[1]);
}

export const RangePicker = withStatics(
  function RangePicker(props: RangePickerProps) {
    const t = useTranslation(moment);
    const { classPrefix } = useConfig();
    const {
      header,
      className,
      style,
      value,
      onChange,
      showTime,
      disabled,
      separator = "~",
      format: _format,
      placeholder = showTime ? t.selectTime : t.selectDate,
      defaultOpen = false,
      open,
      onOpenChange = noop,
      placement = "bottom-start",
      placementOffset = 5,
      closeOnScroll = true,
      escapeWithReference,
      overlayClassName,
      overlayStyle,
      clearable,
      ...restProps
    } = useDefaultValue(props, [null, null]);

    const [hover, setHover] = useState<boolean>(false);

    const format = _format || getFormat(showTime);

    // 当前面板类型
    const [type, setType] = useState<[CalendarTableType, CalendarTableType]>([
      "date",
      "date",
    ]);

    // 当前左/右面板展示时间
    const [curStartView, setStartCurView] = useState<Moment>(
      getDefaultViewMoment(0)
    );
    const [curEndView, setEndCurView] = useState<Moment>(
      getDefaultViewMoment(1)
    );

    // 当前选中日期
    const [curValue, setCurValue] = useState<RangeDateType>(
      isValidRangeValue(value)
        ? [value[0].clone(), value[1].clone()]
        : [null, null]
    );

    // 当前 hover 的日期
    const [hovered, setHovered] = useState<Moment>(null);

    // 上次选中日期
    const preValidValueRef = useRef<RangeDateType>(value || [null, null]);

    // 选择器是否展开
    const [active, setActive] = useDefault(open, defaultOpen, onOpenChange);

    // 输入框显示值
    const inputRef = useRef<HTMLInputElement>(null);
    const getInputValue = useCallback(
      (value: RangeDateType): string => {
        const [start, end] = value || [null, null];
        if (isMoment(start) && isMoment(end)) {
          return `${start
            .locale(t.locale)
            .format(format)} ${separator} ${end
            .locale(t.locale)
            .format(format)}`;
        }
        return "";
      },
      [format, separator, t.locale]
    );
    const [inputValue, setInputValue] = useState<string>(
      getInputValue(curValue)
    );

    useEffect(() => {
      setCurValue(
        isValidRangeValue(value)
          ? [value[0].clone(), value[1].clone()]
          : [null, null]
      );
      setInputValue(getInputValue(value));
    }, [format, separator, value, getInputValue]);

    useEffect(() => {
      preValidValueRef.current = value || [null, null];
    }, [value]);

    function handleChange(
      value: RangeDateType,
      context: DateChangeContext
    ): void {
      // 同步日期/时间
      if (showTime && isValidRangeValue(value)) {
        value = syncDate(value, context.type); // eslint-disable-line no-param-reassign
      }

      setCurValue(value);
      // moment 更改后直接获取值（format）可能拿到是之前值
      setTimeout(() => setInputValue(getInputValue(value)), 0);

      // 没有时间选择时没有二次确认选中
      if (!showTime && isValidRangeValue(value)) {
        onChange(value, context);
        handleClose();
      }
    }

    function handleOk(event): void {
      let value = curValue;
      if (isValidRangeValue(curValue) && curValue[0].isAfter(curValue[1])) {
        value = [curValue[1], curValue[0]];
        setCurValue(value);
      }
      onChange(value, { event });
      handleClose();
    }

    function handleOpen(): void {
      if (disabled) {
        return;
      }
      setActive(true);
      setType(["date", "date"]);
    }

    function handleClose(): void {
      setInputValue(getInputValue(value));
      setActive(false);
    }

    /**
     * 同步日期/时间
     * 如果当前修改为日期，则同步上次时间并修正；
     * 如果当前修改为时间，则同步上次日期；
     */
    function syncDate(
      value: RangeDateType,
      type: CalendarTableType
    ): RangeDateType {
      const preValidValue = preValidValueRef.current;
      const { range, disabledTime = () => ({}) } = props;

      // 如果包含上次选择，则以上次选择为基准同步
      if (isValidRangeValue(preValidValue)) {
        if (type === "date") {
          const timeStart = getValidTimeValue(preValidValue[0], {
            range: getTimeRange(value[0], range),
            ...disabledTime(value, "start"),
          });
          const timeEnd = getValidTimeValue(preValidValue[1], {
            range: getTimeRange(value[1], range),
            ...disabledTime(value, "end"),
          });
          value[0].set(getHourMinuteSecond(timeStart));
          value[1].set(getHourMinuteSecond(timeEnd));
        }
        if (type === "time") {
          value[0].set(getYearMonthDate(preValidValue[0]));
          value[1].set(getYearMonthDate(preValidValue[1]));
        }
        // 如果是首次选择，则将当前时间进行修正
      } else if (type === "date") {
        // 合并 showTime.defaultValue
        if (
          typeof showTime === "object" &&
          isValidRangeValue(showTime.defaultValue)
        ) {
          const [start, end] = showTime.defaultValue;
          value[0].set(getHourMinuteSecond(start));
          value[1].set(getHourMinuteSecond(end));
        }

        const timeStart = getValidTimeValue(value[0], {
          range: getTimeRange(value[0], range),
          ...disabledTime(value, "start"),
        });
        const timeEnd = getValidTimeValue(value[1], {
          range: getTimeRange(value[1], range),
          ...disabledTime(value, "end"),
        });

        value[0].set(getHourMinuteSecond(timeStart));
        value[1].set(getHourMinuteSecond(timeEnd));
      }

      preValidValueRef.current = value;
      return value;
    }

    /**
     * 获取 ShowTime 参数
     * @param index 左/右面板 - 0/1
     */
    function getShowTime(index: number): showTimeType<Moment> {
      if (typeof showTime === "object") {
        if (Array.isArray(showTime.defaultValue)) {
          return { ...showTime, defaultValue: showTime.defaultValue[index] };
        }
        return showTime as showTimeType<Moment>;
      }
      return !!showTime;
    }

    /**
     * 获取左右面板 range
     */
    function getRange(range): [RangeDateType, RangeDateType] {
      const [rangeMin, rangeMax] = range || [null, null];
      const endPreEnd = moment(curEndView)
        .subtract(1, "month")
        .endOf("month");
      const startNxtStart = moment(curStartView)
        .add(1, "month")
        .startOf("month");

      return [
        [rangeMin, endPreEnd.isAfter(rangeMax) ? rangeMax : endPreEnd],
        [startNxtStart.isBefore(rangeMin) ? rangeMin : startNxtStart, rangeMax],
      ];
    }

    /**
     * 获取面板默认展示时间
     * @param index 左/右面板 - 0/1
     */
    function getDefaultViewMoment(index: number): Moment {
      const { range } = props;
      const showTime = getShowTime(index);
      const time =
        showTime && typeof showTime === "object"
          ? showTime.defaultValue
          : undefined;

      // 没有初始值
      if (!isValidRangeValue(value)) {
        let m;
        if (!time) {
          m = moment();
        } else {
          m = moment(getHourMinuteSecond(time as Moment));
        }
        // range 判断
        if (Array.isArray(range)) {
          let [start, end] = range;
          if (!isMoment(start)) {
            start = moment(0);
          }
          if (!isMoment(end)) {
            end = moment(2 ** 52);
          }
          if (end.isBefore(m, "month")) {
            return index === 0 ? moment(end).subtract(1, "month") : end;
          }
          if (start.isAfter(m, "month")) {
            return index === 0 ? start : moment(start).add(1, "month");
          }
          if (isMoment(start) && start.isSame(m, "month")) {
            return index === 0 ? m : moment(m).add(1, "month");
          }
        }
        return index === 0 ? moment(m).subtract(1, "month") : m;
      }

      // 初始值在同个月
      if (value[0].isSame(value[1], "month")) {
        // 根据 range 判断
        if (Array.isArray(range)) {
          // 当前月前一月不可选时，向后显示一月
          if (isMoment(range[0]) && range[0].isSame(value[1], "month")) {
            return index === 0 ? value[1] : moment(value[1]).add(1, "month");
          }
        }
        return index === 0 ? moment(value[1]).subtract(1, "month") : value[1];
      }

      return value[index];
    }

    /**
     * 是否改变当前视图时间
     * 连续两月情况下，点击中间交错日期不改变当前视图时间
     * @param from 当前视图变更事件来源
     * @param nextDate 要变更到的时间
     * @param type 当前视图类型
     */
    function shouldCurViewChange(
      from: string,
      nextDate: Moment,
      type: "start" | "end" = "start"
    ): boolean {
      if (from !== "outside-date") {
        return true;
      }
      const diffMonths = (start, end) => {
        const years = end.year() - start.year();
        return end.month() - start.month() + years * 12;
      };
      if (diffMonths(curStartView, curEndView) === 1) {
        if (type === "start") {
          return diffMonths(curStartView, nextDate) !== 1;
        }
        return diffMonths(nextDate, curEndView) !== 1;
      }
      return true;
    }

    return (
      <Popover
        trigger={[
          DatePickerTrigger,
          { onOpen: handleOpen, onClose: handleClose },
        ]}
        visible={active}
        onVisibleChange={setActive}
        placement={placement}
        placementOffset={placementOffset}
        closeOnScroll={closeOnScroll}
        escapeWithReference={escapeWithReference}
        overlayClassName={overlayClassName}
        overlayStyle={overlayStyle}
        overlay={
          <DropdownBox adaptable>
            <CalendarPart.Panel rangeMode timeMode={type[0] === "time"}>
              {!!header && <CalendarPart.Header>{header}</CalendarPart.Header>}
              <TimeSupportWrapper
                {...restProps}
                showTime={showTime}
                value={curValue}
                onChange={handleChange}
                onOk={handleOk}
                type={type}
                onTypeChange={types =>
                  setType(types as [CalendarTableType, CalendarTableType])
                }
              >
                {({ type, onTypeChange, range, ...props }) => {
                  const [startRange, EndRange] = getRange(range);
                  return (
                    <>
                      <CalendarTable
                        {...props}
                        rangeType="start"
                        range={startRange}
                        type={type[0]}
                        onTypeChange={t => onTypeChange([t, type[1]])}
                        showTime={getShowTime(0)}
                        curViewMoment={curStartView}
                        onCurViewMomentChange={(date, { from } = {}) => {
                          if (!shouldCurViewChange(from, date)) {
                            return;
                          }
                          if (!curEndView.isAfter(date, "month")) {
                            setEndCurView(moment(date).add(1, "month"));
                          }
                          setStartCurView(date);
                        }}
                        dateRangeInRangePicker={range || [null, null]}
                        hovered={hovered}
                        onHoveredChange={setHovered}
                      />
                      <CalendarTable
                        {...props}
                        rangeType="end"
                        range={EndRange}
                        type={type[1]}
                        onTypeChange={t => onTypeChange([type[0], t])}
                        showTime={getShowTime(1)}
                        curViewMoment={curEndView}
                        onCurViewMomentChange={(date, { from } = {}) => {
                          if (!shouldCurViewChange(from, date, "end")) {
                            return;
                          }
                          if (!curStartView.isBefore(date, "month")) {
                            setStartCurView(moment(date).subtract(1, "month"));
                          }
                          setEndCurView(date);
                        }}
                        dateRangeInRangePicker={range || [null, null]}
                        hovered={hovered}
                        onHoveredChange={setHovered}
                      />
                    </>
                  );
                }}
              </TimeSupportWrapper>
            </CalendarPart.Panel>
          </DropdownBox>
        }
      >
        <div
          className={classNames(
            `${classPrefix}-date${showTime ? "time" : ""}picker`,
            className
          )}
          style={style}
        >
          <div
            className={classNames(
              `${classPrefix}-date${showTime ? "time" : ""}picker__input`,
              {
                "is-hover": hover && clearable && isValidRangeValue(value),
              }
            )}
            onMouseEnter={() => setHover(true)}
            onMouseLeave={() => setHover(false)}
          >
            <Input
              ref={inputRef}
              disabled={disabled}
              placeholder={placeholder}
              value={inputValue}
              onFocus={() => inputRef.current.blur()}
            />
            {clearable && (
              <Icon
                type="dismiss"
                onClick={event => {
                  event.stopPropagation();
                  onChange([null, null], { event });
                }}
              />
            )}
          </div>
        </div>
      </Popover>
    );
  },
  { defaultLabelAlign: "middle" }
);
