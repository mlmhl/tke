import React, { useRef, useEffect, useState } from "react";
import classNames from "classnames";
import { useDefaultValue } from "../form";
import { Popover } from "../popover";
import { Input } from "../input";
import { Icon } from "../icon";
import { useTranslation } from "../i18n";
import {
  CascaderBaseProps,
  CascaderMultipleProps,
  CascaderBoxProps,
} from "./CascaderProps";
import { CascaderBox, getOptions } from "./CascaderBox";
import { useDefault } from "../_util/use-default";
import { useConfig } from "../_util/config-context";
import { Tag } from "../tag";
import { noop } from "../_util/noop";

function isEqual(a: string[], b: string[]) {
  return a.length === b.length && a.every((str, i) => str === b[i]);
}

export function CascaderMultiple(
  props: CascaderBaseProps & CascaderMultipleProps
) {
  const t = useTranslation();
  const { classPrefix } = useConfig();
  const {
    data,
    value: valueList,
    onChange,
    onLoad,
    disabled,
    className,
    style,
    placeholder = t.pleaseSelect,
    defaultOpen = false,
    open,
    onOpenChange = noop,
    placement = "bottom-start",
    placementOffset = 5,
    closeOnScroll = true,
    escapeWithReference,
    overlayClassName,
    overlayStyle,
    clearable,
  } = useDefaultValue(props, []);
  const [hover, setHover] = useState<boolean>(false);
  const scheduleUpdateRef = useRef<() => void>(null);
  useEffect(() => {
    if (scheduleUpdateRef.current) {
      scheduleUpdateRef.current();
    }
  }, [valueList]);

  const [isOpened, setIsOpened] = useDefault(open, defaultOpen, onOpenChange);

  const optionsList = valueList.map(v => getOptions(data, v));

  const onSelect: CascaderBoxProps["onChange"] = (value, context) => {
    const next = [...valueList, value];
    onChange(next, { ...context, options: next.map(v => getOptions(data, v)) });
  };

  const onDeselect: CascaderBoxProps["onDeselect"] = (value, context) => {
    const next = valueList.filter(v => !isEqual(v, value));
    onChange(next, { ...context, options: next.map(v => getOptions(data, v)) });
  };

  return (
    <Popover
      trigger={disabled ? "empty" : "click"}
      visible={isOpened}
      onVisibleChange={setIsOpened}
      placement={placement || "bottom-start"}
      placementOffset={placementOffset}
      closeOnScroll={closeOnScroll}
      escapeWithReference={escapeWithReference}
      overlayClassName={overlayClassName}
      overlayStyle={overlayStyle}
      overlay={({ scheduleUpdate }) => {
        scheduleUpdateRef.current = scheduleUpdate;
        return (
          <CascaderBox
            multiple
            data={data}
            onChange={onSelect}
            onLoad={onLoad}
            onClose={() => setIsOpened(false)}
            changeOnSelect={false}
            scheduleUpdate={scheduleUpdate}
            classPrefix={classPrefix}
            isSelected={value => !!valueList.find(v => isEqual(v, value))}
            onDeselect={onDeselect}
          />
        );
      }}
    >
      <div
        className={classNames(`${classPrefix}-cascader`, className)}
        style={style}
        onMouseEnter={() => setHover(true)}
        onMouseLeave={() => setHover(false)}
      >
        <div className={`${classPrefix}-cascader__input`}>
          <div className={`${classPrefix}-cascader__value`}>
            <Tag.Group>
              {optionsList.map((options, index) => {
                const { value = undefined, label = undefined } = options[
                  options.length - 1
                ];
                return (
                  <Tag
                    key={value}
                    onClose={event => {
                      event.stopPropagation();
                      const next = valueList.filter((_, i) => i !== index);
                      onChange(next, {
                        event,
                        options: next.map(v => getOptions(data, v)),
                      });
                    }}
                  >
                    {label || value}
                  </Tag>
                );
              })}
            </Tag.Group>
          </div>
          <Input
            readonly
            autoComplete="off"
            placeholder={valueList.length ? "" : placeholder}
          />
        </div>
        {clearable && hover && valueList.length ? (
          <Icon
            type="dismiss"
            onClick={event => {
              event.stopPropagation();
              onChange([], { event, options: [] });
            }}
          />
        ) : (
          <Icon type="arrowdown" />
        )}
      </div>
    </Popover>
  );
}

CascaderMultiple.defaultLabelAlign = "middle";
