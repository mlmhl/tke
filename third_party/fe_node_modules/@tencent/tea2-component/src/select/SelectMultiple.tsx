import React, { useState, useRef, useEffect, Fragment } from "react";
import { Combine, StyledProps } from "../_type";
import { DropdownProps, Dropdown, CommonDropdownProps } from "../dropdown";
import { List } from "../list";
import { Checkbox } from "../checkbox";
import { useDefaultValue, ControlledProps, ChangeContext } from "../form";
import { SelectOption } from "./SelectOption";
import { CheckTree } from "../checktree";
import { Button } from "../button";
import { Text } from "../text";
import { useTranslation } from "../i18n";
import { withStatics } from "../_util/with-statics";
import { useConfig } from "../_util/config-context";
import { EmptyTip } from "../tips";
import { SearchBox } from "../searchbox";
import { SelectSearchProps } from "./SelectProps";
import { injectValue } from "../_util/inject-value";
import { Tooltip } from "../tooltip";
import { useDefault } from "../_util/use-default";
import { noop } from "../_util/noop";

/**
 * 多选 Props
 */
export interface SelectMultipleProps
  extends Combine<
    SelectSearchProps<SelectOption>,
    CommonDropdownProps,
    StyledProps,
    ControlledProps<string[]>
  > {
  /**
   * 选项列表
   */
  options?: SelectOption[];

  /**
   * 表示全选的选项
   */
  allOption?: SelectOption | false;

  /**
   * 如果开启了全选支持，则可以指定哪些记录从全选的范围内排除
   *
   * - 默认为 'disabled' 可以排除禁用的记录
   * - 提供回调则自定义哪些记录应该排除，对于应该排除的记录，应该返回 `true`
   *
   * @default "disabled"
   */
  shouldOptionExcludeFromAll?: "disabled" | ((option: SelectOption) => boolean);

  /**
   * 是否支持清空
   * @default false
   * @version 2.3.2
   */
  clearable?: boolean;

  /**
   * 允许不选择项
   *
   * @default true
   */
  allowEmpty?: boolean;

  /**
   * 是否暂存操作结果
   *
   * - 设置为 `true`，则会提供确定和取消按钮，确定后才会触发 onChange
   * - 设置为 `false`，则不渲染确定和取消按钮，修改后直接触发 onChange
   *
   * @default true
   */
  staging?: boolean;

  /**
   * 占位符
   * @default "请选择"（已处理国际化）
   */
  placeholder?: string;

  /**
   * 是否禁用
   * @default false
   */
  disabled?: boolean;

  /**
   * 下拉选框的外观
   *
   * - `default` 无边框，适用于页面标题和表格内
   * - `button` 为按钮风格，有边框，多用于操作栏中
   * - `link` 为超链接风格
   * - `filter` 为过滤组件风格，多用于表头筛选
   * - `pure` 无额外样式
   *
   * 原有 `raw` 类型建议使用 `pure` 进行改造
   *
   * @default "default"
   * @version 2.0.9
   */
  appearance?: DropdownProps["appearance"];

  /**
   * **\[Deprecated\]** 请使用 `appearance` 属性
   * @deprecated
   */
  appearence?: DropdownProps["appearence"];

  /**
   * 按钮显示内容，默认会显示当前选中的选项
   *
   * @docType React.ReactNode | ((selectedOptions: SelectOption[]) => React.ReactNode)
   */
  button?:
    | React.ReactNode
    | ((selectedOptions: SelectOption[]) => React.ReactNode);

  /**
   * 下拉框大小
   */
  size?: DropdownProps["size"];

  /**
   * 弹出区域自定义类名
   */
  boxClassName?: DropdownProps["boxClassName"];

  /**
   * 弹出区域自定义样式
   */
  boxStyle?: DropdownProps["boxStyle"];

  /**
   * 可使用字符串或 [StatusTip](/component/tips) 相关组件
   *
   * @docType React.ReactNode | ((selectedOptions: SelectOption[]) => React.ReactNode)
   */
  tips?:
    | React.ReactNode
    | ((selectedOptions: SelectOption[]) => React.ReactNode);

  /**
   * 是否在下拉框收起后清空搜索框
   * @default true
   * @version 2.1.0
   */
  autoClearSearchValue?: boolean;

  /**
   * 展开时回调
   * @version 2.1.0
   */
  onOpen?: DropdownProps["onOpen"];

  /**
   * 收起时回调
   * @version 2.1.0
   */
  onClose?: DropdownProps["onClose"];

  /**
   * 展开时回调
   * @version 2.1.1
   */
  onFocus?: DropdownProps["onFocus"];
}

export const SelectMultiple = withStatics(
  function SelectMultiple(props: SelectMultipleProps) {
    const { classPrefix } = useConfig();
    const {
      staging = true,
      value,
      onChange,
      options = [],
      allOption,
      shouldOptionExcludeFromAll = "disabled",
      allowEmpty = true,
      onOpen = noop,
      onClose = noop,
      searchable,
      searchPlaceholder = "",
      onSearch = noop,
      filter: customizeFilter,
      autoClearSearchValue = true,
      defaultSearchValue = "",
      searchValue,
      onSearchValueChange,
      clearable,
      ...dropdownProps
    } = useDefaultValue(props, []);

    const t = useTranslation();

    const [stagingValue, setStagingValue] = useState<string[]>(value);

    const InputRef = useRef<HTMLInputElement>(null);
    const [inputValue, setInputValue] = useDefault<string, [ChangeContext]>(
      searchValue,
      defaultSearchValue,
      onSearchValueChange
    );

    const filter =
      customizeFilter ||
      ((inputValue: string, { text, value }: SelectOption) => {
        const optionText = String(typeof text === "string" ? text : value);
        return !searchable || optionText.includes(inputValue);
      });

    function focus() {
      if (searchable) {
        setTimeout(() => {
          if (InputRef.current) {
            InputRef.current.focus();
          }
        }, 100); // 第一次展开时 Input 还未渲染
      }
    }
    const handleChange = (value: string[], context: ChangeContext) => {
      if (staging === false) {
        onChange(value, context);
        return;
      }
      setStagingValue(value);
    };

    // 「全部」选项和其余选项是数关系
    const relations = {};
    if (allOption) {
      for (const option of options) {
        if (
          // 用户可以指定哪些选项从全选逻辑中排除
          (typeof shouldOptionExcludeFromAll === "function" &&
            shouldOptionExcludeFromAll(option)) ||
          (shouldOptionExcludeFromAll === "disabled" && option.disabled)
        ) {
          // continue
        } else {
          relations[option.value] = allOption.value;
        }
      }
    }

    // 筛选
    const filteredOptions = options.filter(options =>
      filter(inputValue, options)
    );

    let { tips } = props;
    if (!tips && filteredOptions.length === 0) {
      tips = <EmptyTip />;
    }
    tips = tips ? (
      <List.StatusTip>{injectValue(tips)(filteredOptions)}</List.StatusTip>
    ) : null;

    return (
      <Dropdown
        {...dropdownProps}
        updateOnChildrenChange
        button={<ValueBrief {...props} value={value} />}
        onOpen={() => {
          setStagingValue(value);
          focus();
          onOpen();
        }}
        onClose={() => {
          if (autoClearSearchValue && inputValue !== "") {
            setTimeout(() => {
              setInputValue("", {} as any);
            }, 100);
          }
          onClose();
        }}
        clickClose={false}
        clearable={value.length && clearable}
        onClear={event => {
          onChange([], { event });
          setStagingValue([]);
        }}
      >
        {close => (
          <CheckTree
            relations={relations}
            value={(staging ? stagingValue : value) || value}
            onChange={handleChange}
            disabledNames={options.filter(x => x.disabled).map(x => x.value)}
          >
            {searchable && (
              <SearchBox
                simple
                ref={InputRef}
                value={inputValue}
                onChange={(value, context) => {
                  setInputValue(value, context);
                  onSearch(value, context);
                }}
                onClear={focus}
                placeholder={searchPlaceholder}
                onSearch={onSearch}
              />
            )}
            <List type="option" className={`${classPrefix}-list--checkoption`}>
              {allOption &&
                options.length === filteredOptions.length &&
                renderSelectOption(allOption)}
              {tips}
              {filteredOptions.map(option => renderSelectOption(option))}
            </List>
            {staging !== false && (
              <Dropdown.Footer>
                <Button
                  type="primary"
                  disabled={!allowEmpty && stagingValue.length === 0}
                  onClick={event => {
                    onChange(stagingValue, { event });
                    close();
                  }}
                >
                  {t.okText}
                </Button>
                <Button type="weak" onClick={close}>
                  {t.cancelText}
                </Button>
              </Dropdown.Footer>
            )}
          </CheckTree>
        )}
      </Dropdown>
    );
  },
  {
    defaultLabelAlign: "middle",
  }
);

function renderSelectOption(option: SelectOption): JSX.Element {
  return (
    <List.Item
      key={option.value}
      tooltip={option.tooltip}
      disabled={option.disabled}
    >
      <Checkbox onClick={evt => evt.stopPropagation()} name={option.value}>
        {option.text || option.value}
      </Checkbox>
    </List.Item>
  );
}

function ValueBrief(props: SelectMultipleProps): JSX.Element {
  const t = useTranslation();
  const {
    value,
    allOption,
    options,
    button,
    placeholder = t.pleaseSelect,
    appearance = props.appearence, // eslint-disable-line react/destructuring-assignment
  } = props;

  let buttonPlaceholder: React.ReactNode = placeholder;
  if (!appearance || appearance === "button" || appearance === "default") {
    buttonPlaceholder = <Text theme="weak">{placeholder}</Text>;
  }

  const [selectedOptions, setSelectedOptions] = useState<SelectOption[]>(
    (value || []).map(x => options.find(y => y.value === x)).filter(Boolean)
  );

  useEffect(() => {
    setSelectedOptions(selectedOptions => {
      return (value || [])
        .map(
          v =>
            options.find(option => option.value === v) ||
            selectedOptions.find(option => option.value === v)
        )
        .filter(Boolean);
    });
  }, [options, value]);

  if (button) {
    return <>{injectValue(button)(selectedOptions)}</>;
  }
  if (!value || !value.length) {
    return <>{buttonPlaceholder}</>;
  }
  if (
    allOption &&
    value.length === options.length &&
    value.filter(v => options.find(o => o.value === v)).length ===
      options.length
  ) {
    return <>{allOption.text || allOption.value}</>;
  }

  const exceed = selectedOptions.length > 5;

  const content = (
    <>
      {selectedOptions.slice(0, 5).map((o, index) => (
        <Fragment key={o.value}>
          {o.text || o.value}
          {index < selectedOptions.length - 1 && ", "}
        </Fragment>
      ))}
      {exceed && "..."}
    </>
  );

  return exceed ? (
    <Tooltip title={content}>
      <span>{content}</span>
    </Tooltip>
  ) : (
    content
  );
}
