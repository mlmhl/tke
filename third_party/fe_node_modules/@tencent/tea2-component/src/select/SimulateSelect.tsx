import React, { useRef, useState, useEffect } from "react";
import { Dropdown, DropdownKeyDownContext } from "../dropdown";
import { useTranslation } from "../i18n";
import { useDefaultValue, ChangeContext } from "../form";
import { SelectOptionWithGroup } from "./SelectOption";
import { SearchBox } from "../searchbox";
import { EmptyTip } from "../tips";
import { Text } from "../text";
import { KeyCode } from "../_util/key-code";
import {
  VirtualizedList as List,
  VirtualizedListItem,
} from "../list/VirtualizedList";
import { SimulateSelectProps } from "./SelectProps";
import { injectValue } from "../_util/inject-value";
import { useDefault } from "../_util/use-default";
import { noop } from "../_util/noop";

/**
 * 模拟 Select
 */
export function SimulateSelect(props: SimulateSelectProps) {
  const t = useTranslation();
  const {
    value,
    onChange,
    options = [],
    groups = {},
    placeholder = t.pleaseSelect,
    button,
    size,
    onScrollBottom,
    listHeight,
    bottomTips,
    boxStyle = {},
    onOpen = noop,
    onClose = noop,
    searchable,
    searchPlaceholder = "",
    onSearch = noop,
    filter: customizeFilter,
    defaultSearchValue = "",
    searchValue,
    onSearchValueChange,
    autoClearSearchValue = true,
    clearable,
    appearance = props.appearence, // eslint-disable-line react/destructuring-assignment
    ...dropdownProps
  } = useDefaultValue(props, null);

  const dropdownRef = useRef<HTMLDivElement>(null);

  const listRef = useRef(null);

  const [currentIndex, setCurrentIndex] = useState<number>(0);

  const InputRef = useRef<HTMLInputElement>(null);
  const [inputValue, setInputValue] = useDefault<string, [ChangeContext]>(
    searchValue,
    defaultSearchValue,
    onSearchValueChange
  );

  const filter =
    customizeFilter ||
    ((inputValue: string, { text, value }: SelectOptionWithGroup) => {
      const optionText = String(typeof text === "string" ? text : value);
      return !searchable || optionText.includes(inputValue);
    });

  function focus() {
    if (searchable) {
      setTimeout(() => {
        if (InputRef.current) {
          InputRef.current.focus();
        }
      }, 100); // 第一次展开时 Input 还未渲染
    }
  }

  const selected =
    value != null ? options.find(x => x.value === value) : undefined;

  // 选项消失不影响已选中值显示
  const [buttonOption, setButtonOption] = useState<SelectOptionWithGroup>(
    () => {
      if (!selected) {
        return undefined;
      }
      return selected;
    }
  );

  // options 中有选中项时改变 buttonOption
  useEffect(() => {
    if (selected) {
      setButtonOption(selected);
    }
  }, [options]); // eslint-disable-line react-hooks/exhaustive-deps

  // value 变化时改变 buttonOption 及搜索框状态
  useEffect(() => {
    if (selected) {
      setButtonOption(selected);
    } else {
      setButtonOption(undefined);
    }
  }, [value]); // eslint-disable-line react-hooks/exhaustive-deps

  let buttonPlaceholder: React.ReactNode = placeholder;
  if (!appearance || appearance === "button" || appearance === "default") {
    buttonPlaceholder = <Text theme="weak">{placeholder}</Text>;
  }

  // 按钮文字
  const buttonText: React.ReactNode =
    // eslint-disable-next-line no-nested-ternary
    buttonOption
      ? typeof buttonOption.text === "undefined"
        ? buttonOption.value
        : buttonOption.text
      : buttonPlaceholder || t.pleaseSelect;

  const hasGroup = !!options.find(opt => !!opt.groupKey);

  // 筛选
  const filteredOptions = options.filter(options =>
    filter(inputValue, options)
  );

  // 提示
  let { tips } = props;
  if (typeof tips === "undefined" && filteredOptions.length === 0) {
    tips = <EmptyTip />;
  }

  const items = getListItems({
    tips: injectValue(tips)(filteredOptions),
    bottomTips: injectValue(bottomTips)(filteredOptions),
    groups,
    options: filteredOptions,
  });
  const count = items.length;

  function handleKeyDown(
    source: "dropdown" | "input",
    event: React.KeyboardEvent,
    // input 托管事件时没有 context，此时一定为 open 状态
    context: DropdownKeyDownContext = { open: true },
    close: () => void = () => null
  ) {
    const getOptionIndex = (current: number, step: number = 1) => {
      let flag = 1;
      let index = (current + step + count) % count;
      let item = items[index % count];
      while (flag < count && item.type !== "option") {
        flag += 1;
        index = (index + step + count) % count;
        item = items[index % count];
      }
      return index;
    };

    const ok = () => {
      const item = items[currentIndex % count];

      if (item && item.type === "option" && context.open) {
        // 输入时不能使用空格选中
        if (item.option.disabled) {
          return false;
        }
        onChange(item.option.value, { event });
        close();
      }
      return true;
    };

    switch (event.keyCode) {
      case KeyCode.Space:
        if (source === "input") {
          return false;
        }
        event.preventDefault();
        return ok();

      case KeyCode.Enter:
        return ok();

      case KeyCode.Up:
        event.preventDefault();
        setCurrentIndex(c => {
          const index = getOptionIndex(c, -1);
          if (listRef.current) {
            listRef.current.scrollToItem(index);
          }
          return index;
        });
        break;

      case KeyCode.Down:
        event.preventDefault();
        setCurrentIndex(c => {
          const index = getOptionIndex(c);
          if (listRef.current) {
            listRef.current.scrollToItem(index);
          }
          return index;
        });
        break;

      case KeyCode.Esc:
        close();
        break;
    }
    return true;
  }

  return (
    <Dropdown
      updateOnChildrenChange
      ref={dropdownRef}
      clickClose={false}
      size={size}
      boxStyle={boxStyle}
      appearance={appearance}
      button={
        typeof button !== "undefined"
          ? injectValue(button)(buttonOption)
          : buttonText
      }
      onOpen={() => {
        onOpen();
        focus();
      }}
      onClose={() => {
        onClose();
        // 已经未空值不再次置回初始
        if (autoClearSearchValue) {
          setTimeout(() => {
            setInputValue("", {} as any);
          }, 100);
        }
        if (dropdownRef.current) {
          dropdownRef.current.focus();
        }
      }}
      onKeyDown={(event, context) => handleKeyDown("dropdown", event, context)}
      clearable={buttonOption && clearable}
      onClear={event => {
        onChange(null, { event });
        setButtonOption(null);
      }}
      {...dropdownProps}
    >
      {close => (
        <>
          {searchable && (
            <SearchBox
              simple
              ref={InputRef}
              value={inputValue}
              onChange={(value, context) => {
                setInputValue(value, context);
                onSearch(value, context);
              }}
              onClear={focus}
              placeholder={searchPlaceholder}
              onKeyDown={event =>
                handleKeyDown("input", event, undefined, close)
              }
              onSearch={onSearch}
            />
          )}
          <List
            containerStyle={boxStyle}
            containerClassName={dropdownProps.boxClassName}
            items={items.map((item, index) => {
              if (item.type === "option") {
                const { option } = item;
                return {
                  ...item,
                  props: {
                    disabled: option.disabled,
                    selected: option === selected,
                    current:
                      option !== selected && currentIndex % count === index,
                    onClick: event => {
                      onChange(option.value, { event });
                      close();
                    },
                    tooltip: option.tooltip,
                  },
                };
              }
              return item;
            })}
            virtualizedRef={listRef}
            type={hasGroup ? "option-group" : "option"}
            onScrollBottom={onScrollBottom}
            listHeight={listHeight}
          />
        </>
      )}
    </Dropdown>
  );
}

function getListItems({
  tips,
  bottomTips,
  options,
  groups,
}: Pick<
  SimulateSelectProps,
  "tips" | "bottomTips" | "options" | "groups"
>): VirtualizedListItem<SelectOptionWithGroup>[] {
  const items: VirtualizedListItem<SelectOptionWithGroup>[] = [];
  // tips
  if (tips) {
    items.push({ type: "tips", key: "__tips", text: tips });
  }

  // option/group
  options.forEach((option, index) => {
    if (
      option.groupKey &&
      (index === 0 || option.groupKey !== options[index - 1].groupKey)
    ) {
      items.push({
        type: "group",
        key: `${option.groupKey}-${option.value}`,
        text: groups[option.groupKey],
      });
    }

    items.push({
      type: "option",
      key: option.value,
      text: typeof option.text === "undefined" ? option.value : option.text,
      option,
    });
  });

  // bottomTips
  if (bottomTips) {
    items.push({ type: "tips", key: "__bottom_tips", text: bottomTips });
  }
  return items;
}
