import React, { useState, useMemo } from "react";
import warning from "warning";
import { CheckContext } from "../check";
import { CheckChangeContext, CheckProps } from "../check/Check";
import { ControlledProps, useDefaultValue } from "../form/controlled";

export interface CheckTreeProps extends ControlledProps<string[]> {
  /**
   * 已勾选的叶子节点的 name 集合
   */
  value?: string[];

  /**
   * 勾选的节点变更时回调
   */
  onChange?: (value: string[], context: CheckChangeContext) => void;

  /**
   * 提供树的节点关系，每个子节点对应其父节点
   */
  relations: CheckTreeRelation;

  /**
   * 组件树内容，内部的 <Checkbox /> 状态将被托管
   */
  children?: React.ReactNode;

  /**
   * 禁用的控件 name
   */
  disabledNames?: string[];

  /**
   * 是否支持按 Shift 快捷键时多选
   * @default true
   */
  shiftSelect?: boolean;

  // /**
  //  * disabled 的组件是否从全选的范围内排除
  //  * @default true
  //  */
  // excludeDisabledFromParent?: boolean;
}

/**
 * CheckTree 关系定义 interface
  ```ts
  interface CheckTreeRelation {
    [child: string]: string;
  }
  ```
 */
export interface CheckTreeRelation {
  [child: string]: string;
}

export function CheckTree(props: CheckTreeProps) {
  const {
    relations,
    children,
    value,
    onChange,
    shiftSelect = true,
    disabledNames = [],
  } = useDefaultValue(props);
  const [prevCheck, setPrevCheck] = useState<string>(null);

  const disabledSet = completeDisabledNames(relations, disabledNames);
  const model = useMemo(
    () =>
      getTreeModel(
        relations,
        value,
        disabledSet,
        shiftSelect,
        prevCheck,
        setPrevCheck
      ),
    [disabledSet, prevCheck, relations, shiftSelect, value]
  );

  return (
    <CheckContext.Provider
      value={{
        inject(checkProps) {
          if (checkProps.type !== "checkbox") {
            return checkProps;
          }

          // 没有 name 时不受控
          if (typeof checkProps.name === "undefined") {
            return checkProps;
          }

          warning(
            typeof checkProps.value === "undefined",
            'Component managed by <CheckTree> will ignore the "value" prop'
          );

          // [TODO] Table seclectable
          // warning(
          //   typeof checkProps.disabled === 'undefined',
          //   'Component managed by <CheckTree> will ignore the "disabled" prop'
          // );

          model.visit(checkProps);

          const checkName = checkProps.name;

          return {
            ...model.getNodeState(checkName),
            disabled: disabledNames.includes(checkProps.name),
            // 支持 checkbox 上的 onChange 处理时阻止默认的处理行为
            onChange: (checked, context) => {
              if (typeof checkProps.onChange === "function") {
                checkProps.onChange(checked, context);
                if (context.event.defaultPrevented) {
                  return;
                }
              }
              const selection = model.handleChange(
                checkProps.name,
                checked,
                context.event
              );
              if (typeof onChange === "function") {
                onChange(selection, context);
              }
            },
            ...checkProps,
          };
        },
      }}
    >
      {children}
    </CheckContext.Provider>
  );
}

function completeDisabledNames(
  relations: CheckTreeRelation,
  names: string[]
): Set<string> {
  const nameSet = new Set<string>(names);

  for (let i = 0; i < names.length; ++i) {
    Object.entries(relations).forEach(([child, parent]) => {
      if (names[i] === parent && !nameSet.has(child)) {
        nameSet.add(child);
        names.push(child);
      }
    });
  }

  return nameSet;
}

function isEventWithShiftKey(
  event: React.SyntheticEvent
): event is React.SyntheticEvent & { shiftKey: boolean } {
  return "shiftKey" in event;
}

function getTreeModel(
  relations: CheckTreeRelation,
  selection: string[],
  disabledSet: Set<string>,
  shiftSelect: boolean,
  prevCheck: string,
  setPrevCheck: (name: string) => void
) {
  // find parent via child
  const parentMap = new Map<string, string>();

  // find chilren via parent
  const childrenMap = new Map<string, Set<string>>();

  // build the parent map and children map for perfomance
  for (const [child, parent] of Object.entries(relations)) {
    // set parent for child
    parentMap.set(child, parent);

    // set children for parent
    let childrenSet = childrenMap.get(parent);
    if (!childrenSet) {
      childrenSet = new Set<string>();
      childrenMap.set(parent, childrenSet);
    }
    childrenSet.add(child);
  }

  // selected leaf
  const selectionSet = new Set<string>(selection);

  // find node state via checkName
  const nodeStateMap = new Map<
    string,
    { value: boolean; indeterminate: boolean }
  >();

  // classify check by level
  let levelMap: string[][] = [[]];

  const visited: CheckProps[] = [];

  function visit(check: CheckProps) {
    if (!visited.find(({ name }) => name === check.name)) {
      visited.push(check);
    }
  }

  function calcLevel() {
    const roots = visited
      .filter(check => !parentMap.has(check.name))
      .map(c => c.name);

    if (roots.length) {
      let curLevel = 0;
      levelMap = [roots];
      const nameSet = new Set<string>(roots);

      while (true) {
        levelMap[curLevel + 1] = [];
        /* eslint-disable no-loop-func */
        levelMap[curLevel].forEach(checkName => {
          if (childrenMap.has(checkName)) {
            const children = childrenMap.get(checkName);
            visited.forEach(({ name }) => {
              if (children.has(name) && !nameSet.has(name)) {
                nameSet.add(name);
                levelMap[curLevel + 1].push(name);
              }
            });
          }
        });
        /* eslint-enable no-loop-func */
        curLevel += 1;
        if (!levelMap[curLevel].length) {
          break;
        }
      }
    }
  }

  function getVisitedIndex(checkName: string) {
    let index;
    let level;
    levelMap.forEach((checks, _level) => {
      checks.forEach((name, _index) => {
        if (name === checkName) {
          level = _level;
          index = _index;
        }
      });
    });
    return [level, index];
  }

  function getVisitedName(level: number, index: number) {
    return levelMap[level][index];
  }

  function getNodeState(checkName: string) {
    if (nodeStateMap.has(checkName)) {
      return nodeStateMap.get(checkName);
    }

    const children = childrenMap.get(checkName);

    // 叶子节点直接看是否在选取里
    if (!children) {
      const nodeState = {
        value: selectionSet.has(checkName),
        indeterminate: false,
      };
      nodeStateMap.set(checkName, nodeState);
      return nodeState;
    }

    let hasTouchedChild = false;
    let isAllChildrenChecked = true;
    for (const child of children) {
      if (child === checkName) {
        console.error(
          `Warning: Each node should have a unique "value". (value: "${checkName}")`
        );
        // eslint-disable-next-line no-continue
        continue;
      }
      const childState = getNodeState(child);
      if (childState.value || childState.indeterminate) {
        hasTouchedChild = true;
      }
      if (!childState.value) {
        isAllChildrenChecked = false;
      }
    }

    const nodeState = {
      value: isAllChildrenChecked,
      indeterminate: !isAllChildrenChecked && hasTouchedChild,
    };
    nodeStateMap.set(checkName, nodeState);

    return nodeState;
  }

  function setNodeState(checkName: string, checked: boolean) {
    // disabled
    if (disabledSet.has(checkName)) {
      return;
    }

    const children = childrenMap.get(checkName);

    // 叶子节点，直接设置
    if (!children) {
      if (checked) {
        selectionSet.add(checkName);
      } else {
        selectionSet.delete(checkName);
      }
    }
    // 递归设置
    else {
      for (const child of children) {
        setNodeState(child, checked);
      }
    }
  }

  function getSelection() {
    return Array.from(selectionSet);
  }

  function handleChange(
    checkName: string,
    checked: boolean,
    event: React.SyntheticEvent
  ) {
    // 多选
    if (shiftSelect) {
      if (event && isEventWithShiftKey(event) && event.shiftKey) {
        calcLevel();
        const [level, index] = getVisitedIndex(checkName);
        if (prevCheck !== null) {
          const [prevLevel, prevIndex] = getVisitedIndex(prevCheck);
          if (level === prevLevel) {
            // 清空文字选区
            if ("getSelection" in window) {
              window.getSelection().removeAllRanges();
            }

            const min = index < prevIndex ? index : prevIndex;
            const max = index > prevIndex ? index : prevIndex;
            for (let i = min; i <= max; ++i) {
              setNodeState(getVisitedName(level, i), true);
            }
            setPrevCheck(checkName);
            return getSelection();
          }
        }
      }

      if (checked) {
        setPrevCheck(checkName);
      } else {
        setPrevCheck(null);
      }
    }

    setNodeState(checkName, checked);

    return getSelection();
  }

  return {
    visit,
    getNodeState,
    setNodeState,
    getSelection,
    handleChange,
  };
}
