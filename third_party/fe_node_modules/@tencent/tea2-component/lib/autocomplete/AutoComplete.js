"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importStar(require("react"));
var popover_1 = require("../popover");
var dropdown_1 = require("../dropdown");
var VirtualizedList_1 = require("../list/VirtualizedList");
var form_1 = require("../form");
var text_1 = require("../text");
var tips_1 = require("../tips");
var use_default_1 = require("../_util/use-default");
var key_code_1 = require("../_util/key-code");
function highlight(text, keyword) {
    if (typeof text !== "string") {
        return text;
    }
    return text.split(keyword).map(function (text, index) {
        var key = text + "-" + index;
        if (index >= 1) {
            return (react_1.default.createElement(react_1.Fragment, { key: key },
                react_1.default.createElement("strong", null, keyword),
                text));
        }
        return react_1.default.createElement(text_1.Text, { key: key }, text);
    });
}
function AutoComplete(props) {
    var _a = form_1.useDefaultValue(props), className = _a.className, _b = _a.style, style = _b === void 0 ? {} : _b, onChange = _a.onChange, children = _a.children, _c = _a.options, options = _c === void 0 ? [] : _c, _d = _a.groups, groups = _d === void 0 ? {} : _d, keyword = _a.keyword, onScrollBottom = _a.onScrollBottom, _e = _a.closeOnScroll, closeOnScroll = _e === void 0 ? true : _e, open = _a.open, defaultOpen = _a.defaultOpen, onOpenChange = _a.onOpenChange, popoverProps = tslib_1.__rest(_a, ["className", "style", "onChange", "children", "options", "groups", "keyword", "onScrollBottom", "closeOnScroll", "open", "defaultOpen", "onOpenChange"]);
    var _f = tslib_1.__read(react_1.useState(false), 2), isSelected = _f[0], setIsSelected = _f[1];
    var inputRef = react_1.useRef(null);
    var _g = tslib_1.__read(use_default_1.useDefault(open, defaultOpen, onOpenChange), 2), isOpened = _g[0], setIsOpened = _g[1];
    var _h = tslib_1.__read(react_1.useState(undefined), 2), dropdownWidth = _h[0], setDropdownWidth = _h[1];
    var _j = tslib_1.__read(react_1.useState(0), 2), currentIndex = _j[0], setCurrentIndex = _j[1];
    var listRef = react_1.useRef(null);
    var hasGroup = !!options.find(function (opt) { return !!opt.groupKey; });
    var _k = props.tips, tips = _k === void 0 ? react_1.default.createElement(tips_1.EmptyTip, null) : _k;
    if (options.length === 0) {
        tips = typeof tips === "string" ? react_1.default.createElement(tips_1.EmptyTip, { emptyText: tips }) : tips;
    }
    else {
        tips = null;
    }
    var items = getListItems({
        tips: tips,
        groups: groups,
        options: options,
    });
    var count = items.length;
    var getOptionIndex = react_1.useCallback(function (current, step) {
        if (step === void 0) { step = 1; }
        var flag = 1;
        var index = (current + step + count) % count;
        var item = items[index % count];
        while (flag < count && !item.option) {
            flag += 1;
            index = (index + step + count) % count;
            item = items[index % count];
        }
        return index;
    }, [items, count]);
    react_1.useEffect(function () {
        if (!inputRef.current)
            return null;
        function handleKeyDown(event) {
            var option = (items[currentIndex % count] || {}).option;
            switch (event.keyCode) {
                case key_code_1.KeyCode.Up:
                    event.preventDefault();
                    setCurrentIndex(function (c) {
                        var index = getOptionIndex(c, -1);
                        if (listRef.current) {
                            listRef.current.scrollToItem(index);
                        }
                        return index;
                    });
                    break;
                case key_code_1.KeyCode.Down:
                    event.preventDefault();
                    setCurrentIndex(function (c) {
                        var index = getOptionIndex(c);
                        if (listRef.current) {
                            listRef.current.scrollToItem(index);
                        }
                        return index;
                    });
                    break;
                case key_code_1.KeyCode.Enter:
                    if (isOpened && option) {
                        if (option.disabled)
                            break;
                        setIsOpened(false);
                        onChange(option.value, { event: event });
                    }
                    break;
                case key_code_1.KeyCode.Esc:
                    setIsOpened(false);
                    inputRef.current.blur();
                    break;
                default:
                    setCurrentIndex(0);
                    break;
            }
        }
        inputRef.current.addEventListener("keydown", handleKeyDown);
        return function () {
            inputRef.current.removeEventListener("keydown", handleKeyDown);
        };
    }, [
        currentIndex,
        inputRef,
        isOpened,
        onChange,
        options,
        setIsOpened,
        items,
        count,
        getOptionIndex,
    ]);
    var boxStyle = tslib_1.__assign({ width: dropdownWidth }, style);
    return (react_1.default.createElement(popover_1.Popover, tslib_1.__assign({ escapeWithReference: true, animationScaleFrom: 1, transitionTimeout: { enter: 0, exit: 0 }, trigger: [AutoCompleteTrigger, { setIsSelected: setIsSelected }], placement: "bottom-start", visible: isOpened && !isSelected, onVisibleChange: setIsOpened, placementOffset: 5, closeOnScroll: closeOnScroll }, popoverProps, { overlay: react_1.default.createElement(dropdown_1.DropdownBox, { className: className, style: boxStyle },
            react_1.default.createElement(VirtualizedList_1.VirtualizedList, { containerStyle: boxStyle, containerClassName: className, virtualizedRef: listRef, type: hasGroup ? "option-group" : "option", items: items.map(function (item, index) {
                    if (item.type === "option") {
                        var option_1 = item.option;
                        return tslib_1.__assign(tslib_1.__assign({}, item), { props: {
                                disabled: option_1.disabled,
                                current: currentIndex % count === index,
                                onClick: function (event) {
                                    event.stopPropagation();
                                    inputRef.current.focus();
                                    onChange(option_1.value, { event: event });
                                    setIsSelected(true);
                                    setCurrentIndex(index);
                                },
                                tooltip: option_1.tooltip,
                            } });
                    }
                    return item;
                }), onScrollBottom: onScrollBottom })) }), children(function (dom) {
        inputRef.current = dom;
        if (dom) {
            setDropdownWidth(dom.offsetWidth);
        }
    }, { close: function () { return setIsOpened(false); } })));
}
exports.AutoComplete = AutoComplete;
function AutoCompleteTrigger(_a) {
    var visible = _a.visible, setVisible = _a.setVisible, _b = _a.openDelay, openDelay = _b === void 0 ? 0 : _b, _c = _a.closeDelay, closeDelay = _c === void 0 ? 0 : _c, render = _a.render, setIsSelected = _a.setIsSelected;
    var commonProps = {
        onFocus: function () { return setVisible(true, openDelay); },
        onChange: function () {
            setIsSelected(false);
            if (!visible) {
                setVisible(true, openDelay);
            }
        },
        onClick: function () {
            setIsSelected(false);
            if (!visible) {
                setVisible(true, openDelay);
            }
        },
        onBlur: function () { return setVisible(false, closeDelay); },
    };
    return render({
        overlayProps: tslib_1.__assign(tslib_1.__assign({}, commonProps), { tabIndex: 1000 }),
        childrenProps: commonProps,
    });
}
exports.AutoCompleteTrigger = AutoCompleteTrigger;
AutoComplete.defaultLabelAlign = "middle";
function getListItems(_a) {
    var tips = _a.tips, options = _a.options, groups = _a.groups;
    var items = [];
    // tips
    if (tips) {
        items.push({ type: "tips", key: "__auto_complete_tips", text: tips });
    }
    options.forEach(function (option, index) {
        if (option.groupKey &&
            (index === 0 || option.groupKey !== options[index - 1].groupKey)) {
            items.push({
                type: "group",
                key: option.groupKey + "-" + option.value,
                text: groups[option.groupKey],
            });
        }
        items.push({
            type: "option",
            key: option.value,
            text: typeof option.text === "undefined" ? option.value : option.text,
            option: option,
        });
    });
    return items;
}
//# sourceMappingURL=AutoComplete.js.map