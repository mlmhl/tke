"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importStar(require("react"));
var classnames_1 = tslib_1.__importDefault(require("classnames"));
var overlay_1 = require("../overlay");
var useDelayVisible_1 = require("./useDelayVisible");
var use_parent_scroll_1 = require("../_util/use-parent-scroll");
var trigger_1 = require("./trigger");
var merge_style_1 = require("../_util/merge-style");
var domref_1 = require("../domref");
var merge_refs_1 = require("../_util/merge-refs");
function Popover(props) {
    var _a;
    var overlay = props.overlay, _b = props.trigger, trigger = _b === void 0 ? "hover" : _b, _c = props.placement, placement = _c === void 0 ? "top" : _c, _d = props.placementOffset, placementOffset = _d === void 0 ? 10 : _d, escapeWithReference = props.escapeWithReference, children = props.children, closeOnScroll = props.closeOnScroll, overlayClassName = props.overlayClassName, overlayStyle = props.overlayStyle, openDelay = props.openDelay, closeDelay = props.closeDelay, updateOnDimensionChange = props.updateOnDimensionChange, animationScaleFrom = props.animationScaleFrom, transitionTimeout = props.transitionTimeout;
    var overlayRef = react_1.useRef(null);
    var childrenRef = react_1.useRef(null);
    var _e = useDelayVisible_1.useDelayVisible(props), visible = _e.visible, setVisible = _e.setVisible;
    // 设置了 closeOnScroll，则使用
    use_parent_scroll_1.useParentScroll(childrenRef, visible && closeOnScroll && (function () { return setVisible(false, closeDelay); }));
    var Trigger;
    var triggerExtraProps = {};
    // 使用指定的触发交互组件
    if (typeof trigger === "string") {
        Trigger = trigger_1.buildinTriggers[trigger];
    }
    // 支持附加 props 的触发器
    else if (Array.isArray(trigger)) {
        _a = tslib_1.__read(trigger, 2), Trigger = _a[0], triggerExtraProps = _a[1];
    }
    // 本身就是 Trigger 组件
    else {
        Trigger = trigger;
    }
    // fallback
    Trigger = Trigger || trigger_1.buildinTriggers.empty;
    var hasOneValidElement = react_1.default.Children.count(children) === 1 &&
        react_1.default.isValidElement(react_1.default.Children.toArray(children)[0]);
    return (react_1.default.createElement(Trigger, tslib_1.__assign({}, triggerExtraProps, { overlayElementRef: overlayRef, childrenElementRef: childrenRef, visible: visible, setVisible: setVisible, openDelay: openDelay, closeDelay: closeDelay, render: function (_a) {
            var overlayProps = _a.overlayProps, childrenProps = _a.childrenProps, referenceElement = _a.referenceElement;
            return (react_1.default.createElement(overlay_1.Overlay, { layers: [
                    react_1.default.createElement(overlay_1.Overlay.Layer, { key: "popover", visible: visible, placement: placement, placementOffset: placementOffset, animationScaleFrom: animationScaleFrom, referenceElement: props.referenceElement || referenceElement, content: overlay, overlayRef: function (overlayElement) {
                            overlayRef.current = overlayElement;
                        }, overlayProps: tslib_1.__assign(tslib_1.__assign({}, overlayProps), { className: classnames_1.default(overlayProps.className, overlayClassName), style: merge_style_1.mergeStyle({
                                // 已经隐藏之后，动画过程不响应事件
                                pointerEvents: visible ? null : "none",
                            }, overlayProps.style, overlayStyle) }), updateOnDimensionChange: updateOnDimensionChange, transitionTimeout: transitionTimeout, escapeWithReference: escapeWithReference }),
                ] }, function (ref) { return (react_1.default.createElement(domref_1.DomRef, tslib_1.__assign({}, childrenProps, { ref: merge_refs_1.mergeRefs(ref, childrenRef) }), hasOneValidElement ? (react_1.default.Children.toArray(children)[0]) : (react_1.default.createElement("span", null, children)))); }));
        } })));
}
exports.Popover = Popover;
//# sourceMappingURL=Popover.js.map