"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importStar(require("react"));
var warning_1 = tslib_1.__importDefault(require("warning"));
var check_1 = require("../check");
var controlled_1 = require("../form/controlled");
function CheckTree(props) {
    var _a = controlled_1.useDefaultValue(props), relations = _a.relations, children = _a.children, value = _a.value, onChange = _a.onChange, _b = _a.shiftSelect, shiftSelect = _b === void 0 ? true : _b, _c = _a.disabledNames, disabledNames = _c === void 0 ? [] : _c;
    var _d = tslib_1.__read(react_1.useState(null), 2), prevCheck = _d[0], setPrevCheck = _d[1];
    var disabledSet = completeDisabledNames(relations, disabledNames);
    var model = react_1.useMemo(function () {
        return getTreeModel(relations, value, disabledSet, shiftSelect, prevCheck, setPrevCheck);
    }, [disabledSet, prevCheck, relations, shiftSelect, value]);
    return (react_1.default.createElement(check_1.CheckContext.Provider, { value: {
            inject: function (checkProps) {
                if (checkProps.type !== "checkbox") {
                    return checkProps;
                }
                // 没有 name 时不受控
                if (typeof checkProps.name === "undefined") {
                    return checkProps;
                }
                warning_1.default(typeof checkProps.value === "undefined", 'Component managed by <CheckTree> will ignore the "value" prop');
                // [TODO] Table seclectable
                // warning(
                //   typeof checkProps.disabled === 'undefined',
                //   'Component managed by <CheckTree> will ignore the "disabled" prop'
                // );
                model.visit(checkProps);
                var checkName = checkProps.name;
                return tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, model.getNodeState(checkName)), { disabled: disabledNames.includes(checkProps.name), 
                    // 支持 checkbox 上的 onChange 处理时阻止默认的处理行为
                    onChange: function (checked, context) {
                        if (typeof checkProps.onChange === "function") {
                            checkProps.onChange(checked, context);
                            if (context.event.defaultPrevented) {
                                return;
                            }
                        }
                        var selection = model.handleChange(checkProps.name, checked, context.event);
                        if (typeof onChange === "function") {
                            onChange(selection, context);
                        }
                    } }), checkProps);
            },
        } }, children));
}
exports.CheckTree = CheckTree;
function completeDisabledNames(relations, names) {
    var nameSet = new Set(names);
    var _loop_1 = function (i) {
        Object.entries(relations).forEach(function (_a) {
            var _b = tslib_1.__read(_a, 2), child = _b[0], parent = _b[1];
            if (names[i] === parent && !nameSet.has(child)) {
                nameSet.add(child);
                names.push(child);
            }
        });
    };
    for (var i = 0; i < names.length; ++i) {
        _loop_1(i);
    }
    return nameSet;
}
function isEventWithShiftKey(event) {
    return "shiftKey" in event;
}
function getTreeModel(relations, selection, disabledSet, shiftSelect, prevCheck, setPrevCheck) {
    var e_1, _a;
    // find parent via child
    var parentMap = new Map();
    // find chilren via parent
    var childrenMap = new Map();
    try {
        // build the parent map and children map for perfomance
        for (var _b = tslib_1.__values(Object.entries(relations)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = tslib_1.__read(_c.value, 2), child = _d[0], parent_1 = _d[1];
            // set parent for child
            parentMap.set(child, parent_1);
            // set children for parent
            var childrenSet = childrenMap.get(parent_1);
            if (!childrenSet) {
                childrenSet = new Set();
                childrenMap.set(parent_1, childrenSet);
            }
            childrenSet.add(child);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // selected leaf
    var selectionSet = new Set(selection);
    // find node state via checkName
    var nodeStateMap = new Map();
    // classify check by level
    var levelMap = [[]];
    var visited = [];
    function visit(check) {
        if (!visited.find(function (_a) {
            var name = _a.name;
            return name === check.name;
        })) {
            visited.push(check);
        }
    }
    function calcLevel() {
        var roots = visited
            .filter(function (check) { return !parentMap.has(check.name); })
            .map(function (c) { return c.name; });
        if (roots.length) {
            var curLevel_1 = 0;
            levelMap = [roots];
            var nameSet_1 = new Set(roots);
            while (true) {
                levelMap[curLevel_1 + 1] = [];
                /* eslint-disable no-loop-func */
                levelMap[curLevel_1].forEach(function (checkName) {
                    if (childrenMap.has(checkName)) {
                        var children_1 = childrenMap.get(checkName);
                        visited.forEach(function (_a) {
                            var name = _a.name;
                            if (children_1.has(name) && !nameSet_1.has(name)) {
                                nameSet_1.add(name);
                                levelMap[curLevel_1 + 1].push(name);
                            }
                        });
                    }
                });
                /* eslint-enable no-loop-func */
                curLevel_1 += 1;
                if (!levelMap[curLevel_1].length) {
                    break;
                }
            }
        }
    }
    function getVisitedIndex(checkName) {
        var index;
        var level;
        levelMap.forEach(function (checks, _level) {
            checks.forEach(function (name, _index) {
                if (name === checkName) {
                    level = _level;
                    index = _index;
                }
            });
        });
        return [level, index];
    }
    function getVisitedName(level, index) {
        return levelMap[level][index];
    }
    function getNodeState(checkName) {
        var e_2, _a;
        if (nodeStateMap.has(checkName)) {
            return nodeStateMap.get(checkName);
        }
        var children = childrenMap.get(checkName);
        // 叶子节点直接看是否在选取里
        if (!children) {
            var nodeState_1 = {
                value: selectionSet.has(checkName),
                indeterminate: false,
            };
            nodeStateMap.set(checkName, nodeState_1);
            return nodeState_1;
        }
        var hasTouchedChild = false;
        var isAllChildrenChecked = true;
        try {
            for (var children_2 = tslib_1.__values(children), children_2_1 = children_2.next(); !children_2_1.done; children_2_1 = children_2.next()) {
                var child = children_2_1.value;
                if (child === checkName) {
                    console.error("Warning: Each node should have a unique \"value\". (value: \"" + checkName + "\")");
                    // eslint-disable-next-line no-continue
                    continue;
                }
                var childState = getNodeState(child);
                if (childState.value || childState.indeterminate) {
                    hasTouchedChild = true;
                }
                if (!childState.value) {
                    isAllChildrenChecked = false;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (children_2_1 && !children_2_1.done && (_a = children_2.return)) _a.call(children_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var nodeState = {
            value: isAllChildrenChecked,
            indeterminate: !isAllChildrenChecked && hasTouchedChild,
        };
        nodeStateMap.set(checkName, nodeState);
        return nodeState;
    }
    function setNodeState(checkName, checked) {
        var e_3, _a;
        // disabled
        if (disabledSet.has(checkName)) {
            return;
        }
        var children = childrenMap.get(checkName);
        // 叶子节点，直接设置
        if (!children) {
            if (checked) {
                selectionSet.add(checkName);
            }
            else {
                selectionSet.delete(checkName);
            }
        }
        // 递归设置
        else {
            try {
                for (var children_3 = tslib_1.__values(children), children_3_1 = children_3.next(); !children_3_1.done; children_3_1 = children_3.next()) {
                    var child = children_3_1.value;
                    setNodeState(child, checked);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (children_3_1 && !children_3_1.done && (_a = children_3.return)) _a.call(children_3);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
    }
    function getSelection() {
        return Array.from(selectionSet);
    }
    function handleChange(checkName, checked, event) {
        // 多选
        if (shiftSelect) {
            if (event && isEventWithShiftKey(event) && event.shiftKey) {
                calcLevel();
                var _a = tslib_1.__read(getVisitedIndex(checkName), 2), level = _a[0], index = _a[1];
                if (prevCheck !== null) {
                    var _b = tslib_1.__read(getVisitedIndex(prevCheck), 2), prevLevel = _b[0], prevIndex = _b[1];
                    if (level === prevLevel) {
                        // 清空文字选区
                        if ("getSelection" in window) {
                            window.getSelection().removeAllRanges();
                        }
                        var min = index < prevIndex ? index : prevIndex;
                        var max = index > prevIndex ? index : prevIndex;
                        for (var i = min; i <= max; ++i) {
                            setNodeState(getVisitedName(level, i), true);
                        }
                        setPrevCheck(checkName);
                        return getSelection();
                    }
                }
            }
            if (checked) {
                setPrevCheck(checkName);
            }
            else {
                setPrevCheck(null);
            }
        }
        setNodeState(checkName, checked);
        return getSelection();
    }
    return {
        visit: visit,
        getNodeState: getNodeState,
        setNodeState: setNodeState,
        getSelection: getSelection,
        handleChange: handleChange,
    };
}
//# sourceMappingURL=CheckTree.js.map