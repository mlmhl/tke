"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importStar(require("react"));
var classnames_1 = tslib_1.__importDefault(require("classnames"));
var call_both_1 = require("../../../_util/call-both");
var merge_style_1 = require("../../../_util/merge-style");
var merge_refs_1 = require("../../../_util/merge-refs");
var get_scrollbar_size_1 = require("../../../_util/get-scrollbar-size");
var config_context_1 = require("../../../_util/config-context");
/**
 * 滚动 Context 实例
 */
var ScrollContext = react_1.createContext(null);
ScrollContext.displayName = "Scrollable";
/**
 * 注入到外层容器，提供滚动上下文
 */
function ScrollableTable(_a) {
    var table = _a.table, scrollHeightFactor = _a.scrollHeightFactor, _b = _a.onScrollBottom, onScrollBottom = _b === void 0 ? function () { return null; } : _b, props = tslib_1.__rest(_a, ["table", "scrollHeightFactor", "onScrollBottom"]);
    var classPrefix = config_context_1.useConfig().classPrefix;
    // 当前滚动区域是否在滚动状态
    var _c = tslib_1.__read(react_1.useState(false), 2), bodyHasScroll = _c[0], setBodyHasScroll = _c[1];
    // 滚动区域的 DOM 引用
    var bodyRef = react_1.useRef(null);
    // 决定滚动高度的因子改变后，重新检测滚动状态，设置到 bodyHasScroll 中
    react_1.useEffect(function () {
        var bodyBox = bodyRef.current;
        if (bodyBox) {
            // 滚动状态下，scrollHeight > clientHeight
            var nextBodyHasScroll = bodyBox.scrollHeight > bodyBox.clientHeight;
            if (bodyHasScroll !== nextBodyHasScroll) {
                setBodyHasScroll(nextBodyHasScroll);
            }
        }
    }, [bodyHasScroll, scrollHeightFactor]);
    function handleBodyScroll(event) {
        var bodyBox = event.target;
        var scrollHeight = bodyBox.scrollHeight, scrollTop = bodyBox.scrollTop, clientHeight = bodyBox.clientHeight;
        if (bodyHasScroll && scrollHeight <= Math.round(clientHeight + scrollTop)) {
            onScrollBottom(event);
        }
    }
    // 滚动上下文
    var scrollContext = {
        // 提供给 body 使用，提供 body DOM 实例
        setBodyRef: function (body) {
            bodyRef.current = body;
        },
        // 提供给 head 使用，通过滚动状态决定是否增加右侧间距
        bodyHasScroll: bodyHasScroll,
        onScrollCapture: handleBodyScroll,
    };
    return (react_1.default.createElement(ScrollContext.Provider, { value: scrollContext }, react_1.default.cloneElement(table, tslib_1.__assign(tslib_1.__assign({}, props), { 
        // 设计通过提供 tea-table--scrollable 类来开启滚动区域的 overflow: auto
        className: classnames_1.default(table.props.className, classPrefix + "-table--scrollable") }))));
}
exports.ScrollableTable = ScrollableTable;
/**
 * 包装表格内容区（滚动部分），回调内容区 DOM 的实例
 */
exports.ScrollableTableBody = react_1.forwardRef(function (_a, ref) {
    var body = _a.body, style = _a.style, bodyDeps = _a.bodyDeps, scrollToTopOnChange = _a.scrollToTopOnChange, props = tslib_1.__rest(_a, ["body", "style", "bodyDeps", "scrollToTopOnChange"]);
    var bodyRef = react_1.useRef(null);
    react_1.useEffect(function () {
        if (scrollToTopOnChange && bodyRef.current) {
            bodyRef.current.scrollTop = 0;
            bodyRef.current.scrollLeft = 0;
        }
    }, tslib_1.__spread([scrollToTopOnChange], bodyDeps)); // eslint-disable-line react-hooks/exhaustive-deps
    var _b = react_1.useContext(ScrollContext), setBodyRef = _b.setBodyRef, onScrollCapture = _b.onScrollCapture;
    return react_1.default.cloneElement(body, tslib_1.__assign(tslib_1.__assign({}, props), { 
        // 使用 mergeRefs 可以使得其他插件的 ref 也能被调用到
        ref: merge_refs_1.mergeRefs(setBodyRef, body.ref, ref, bodyRef), style: merge_style_1.mergeStyle(body.props.style, style), onScrollCapture: call_both_1.callBoth(body.props.onScrollCapture, onScrollCapture) }));
});
/**
 * 包装表格头部，通过滚动状态调整右侧间距
 */
exports.ScrollableTableHead = react_1.forwardRef(function (_a, ref) {
    var head = _a.head, props = tslib_1.__rest(_a, ["head"]);
    var bodyHasScroll = react_1.useContext(ScrollContext).bodyHasScroll;
    return react_1.default.cloneElement(head, tslib_1.__assign(tslib_1.__assign({}, props), { ref: merge_refs_1.mergeRefs(head.ref, ref), style: merge_style_1.mergeStyle(head.props.style, {
            marginRight: bodyHasScroll ? get_scrollbar_size_1.getScrollBarSize() : null,
        }) }));
});
ScrollableTable.displayName = "ScrollableTable";
//# sourceMappingURL=ScrollableTable.js.map