"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importStar(require("react"));
var warning_1 = tslib_1.__importDefault(require("warning"));
var classnames_1 = tslib_1.__importDefault(require("classnames"));
var checktree_1 = require("../../checktree");
var checkbox_1 = require("../../checkbox");
var get_row_key_from_record_key_1 = require("../util/get-row-key-from-record-key");
var check_1 = require("../../check");
var inject_props_if_target_not_existed_1 = require("../util/inject-props-if-target-not-existed");
var config_context_1 = require("../../_util/config-context");
function selectable(options) {
    var _a = options.relations, relations = _a === void 0 ? {} : _a, value = options.value, onChange = options.onChange, _b = options.all, all = _b === void 0 ? true : _b, targetColumnKey = options.targetColumnKey, indent = options.indent, rowSelect = options.rowSelect, _c = options.width, width = _c === void 0 ? 26 : _c, _d = options.render, render = _d === void 0 ? function (x) { return x; } : _d, _e = options.shouldRecordExcludeFromAll, shouldRecordExcludeFromAll = _e === void 0 ? "disabled" : _e, _f = options.rowSelectable, rowSelectable = _f === void 0 ? function () { return true; } : _f;
    if (typeof indent !== "undefined") {
        warning_1.default(false, "Property `indent` is deprecated. Please use `indentable` addon instead.");
    }
    var fallbackColumnKey = "__selectable_addon__";
    var fallbackAllKey = "__selectable_all__";
    var allKey = typeof all === "string" ? all : fallbackAllKey;
    var rowDisabled = null;
    return {
        onInjectProps: function (props) {
            var columns = props.columns;
            rowDisabled = props.rowDisabled || (function () { return false; });
            columns = inject_props_if_target_not_existed_1.injectPropsIfTargetNotExisted(columns, targetColumnKey, {
                key: fallbackColumnKey,
                width: width,
                header: null,
                render: function () { return null; },
            });
            return tslib_1.__assign(tslib_1.__assign({}, props), { columns: columns });
        },
        onInjectColumn: function (previous) { return function (record, rowKey, recordIndex, column, columnIndex) {
            // 不是目标列
            if (column.key !== targetColumnKey && column.key !== fallbackColumnKey) {
                return previous(record, rowKey, recordIndex, column, columnIndex);
            }
            var _a = previous(record, rowKey, recordIndex, column, columnIndex), preChildren = _a.children, props = _a.props, result = tslib_1.__rest(_a, ["children", "props"]);
            var children = preChildren;
            // 表头
            if (recordIndex === -1) {
                children = (react_1.default.createElement(react_1.default.Fragment, null,
                    react_1.default.createElement(checkbox_1.Checkbox, { style: all ? undefined : { display: "none" }, name: allKey }, children || react_1.default.createElement(react_1.default.Fragment, null, "\u00A0")),
                    !all ? children : null));
            }
            // 记录行
            else {
                var paddingLeft = 0;
                var depth = 0;
                if (indent > 0) {
                    var node = rowKey;
                    while (relations && relations[node]) {
                        depth += 1;
                        node = relations[node];
                    }
                    paddingLeft = indent * depth;
                }
                var checkbox = (react_1.default.createElement(TableCheckbox, { name: rowKey }, children || react_1.default.createElement(react_1.default.Fragment, null, "\u00A0")));
                var element = paddingLeft ? (react_1.default.createElement("div", { style: { paddingLeft: paddingLeft } }, checkbox)) : (checkbox);
                children = render(element, {
                    children: preChildren,
                    record: record,
                    depth: depth,
                    rowKey: rowKey,
                    recordIndex: recordIndex,
                    disabled: rowDisabled(record),
                });
            }
            return tslib_1.__assign(tslib_1.__assign({}, result), { props: props, children: children });
        }; },
        onInjectTable: function (renderBody) { return function (props) {
            var e_1, _a;
            var recordKey = props.recordKey, records = props.records, _b = props.rowDisabled, rowDisabled = _b === void 0 ? function () { return false; } : _b;
            var rowKey = get_row_key_from_record_key_1.getRowKeyFromRecordKey(recordKey);
            // 哪些应该从 all 里面排除
            var shouldRecordExcludeFromAllFinal = null;
            if (typeof shouldRecordExcludeFromAll === "function") {
                shouldRecordExcludeFromAllFinal = shouldRecordExcludeFromAll;
            }
            else if (shouldRecordExcludeFromAll === "disabled") {
                shouldRecordExcludeFromAllFinal = rowDisabled;
            }
            shouldRecordExcludeFromAllFinal =
                shouldRecordExcludeFromAllFinal || (function () { return false; });
            var relationsKeys = Object.keys(relations);
            var childrenMap = {};
            relationsKeys.forEach(function (child) {
                var parent = relations[child];
                if (!childrenMap[parent]) {
                    childrenMap[parent] = [];
                }
                childrenMap[parent].push(child);
            });
            var disabledKeys = Array.from(new Set(tslib_1.__spread(relationsKeys, records.map(rowKey)))).filter(function (key) {
                return !rowSelectable(key, {
                    parent: relations[key],
                    children: childrenMap[relations[key]],
                });
            });
            // all keys
            var keys = Array.from(new Set(tslib_1.__spread(relationsKeys, records
                .filter(function (x) { return !shouldRecordExcludeFromAllFinal(x); })
                .map(rowKey)
                .filter(function (x) {
                return shouldRecordExcludeFromAll === "disabled"
                    ? !disabledKeys.includes(x)
                    : true;
            }))));
            // keys without children
            var rootKeys = relations ? keys.filter(function (key) { return !relations[key]; }) : keys;
            var relationWithLeafs = tslib_1.__assign({}, (relations || {}));
            try {
                for (var rootKeys_1 = tslib_1.__values(rootKeys), rootKeys_1_1 = rootKeys_1.next(); !rootKeys_1_1.done; rootKeys_1_1 = rootKeys_1.next()) {
                    var key = rootKeys_1_1.value;
                    relationWithLeafs[key] = allKey;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (rootKeys_1_1 && !rootKeys_1_1.done && (_a = rootKeys_1.return)) _a.call(rootKeys_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            // 只有全选 Check 可用时
            var hasRelations = !!Object.keys(relationWithLeafs).length;
            return (react_1.default.createElement(checktree_1.CheckTree, { relations: relationWithLeafs, value: value, onChange: hasRelations
                    ? function (value, context) {
                        return onChange(value, tslib_1.__assign(tslib_1.__assign({}, context), { record: records.find(function (record, index) {
                                return context.check.name === rowKey(record, index);
                            }), selectedRecords: records.filter(function (record, index) {
                                return value.includes(rowKey(record, index));
                            }) }));
                    }
                    : null, disabledNames: tslib_1.__spread(records.filter(function (x) { return rowDisabled(x); }).map(rowKey), disabledKeys) }, renderBody(props)));
        }; },
        onInjectRow: function (renderRow) { return function (record, rowKey, recordIndex, columns) {
            var _a = renderRow(record, rowKey, recordIndex, columns), prepends = _a.prepends, appends = _a.appends, preRow = _a.row;
            var row = preRow;
            // 支持整行选择
            row = (react_1.default.createElement(SelectWrapper, { key: rowKey, name: rowKey, rowSelect: rowSelect && !rowDisabled(record) }, row));
            return { prepends: prepends, row: row, appends: appends };
        }; },
    };
}
exports.selectable = selectable;
function SelectWrapper(_a) {
    var name = _a.name, rowSelect = _a.rowSelect, children = _a.children, props = tslib_1.__rest(_a, ["name", "rowSelect", "children"]);
    var context = react_1.useContext(check_1.CheckContext);
    if (context) {
        var checkProps_1 = context.inject({ type: "checkbox", name: name });
        var onChange_1 = checkProps_1.onChange, value_1 = checkProps_1.value;
        var rowSelectProps = {
            onClick: function (event) {
                // 事件合并
                if (typeof props.onClick === "function") {
                    props.onClick(event);
                }
                if (typeof children.props.onClick === "function") {
                    children.props.onClick(event);
                }
                return onChange_1(!value_1, { event: event, check: checkProps_1 });
            },
        };
        return react_1.default.cloneElement(children, tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, props), { className: classnames_1.default(props.className, children.props.className, {
                "is-selected": !!value_1,
            }) }), (rowSelect ? rowSelectProps : {})));
    }
    return children;
}
function TableCheckbox(_a) {
    var children = _a.children, props = tslib_1.__rest(_a, ["children"]);
    var classPrefix = config_context_1.useConfig().classPrefix;
    return (react_1.default.createElement(checkbox_1.Checkbox, tslib_1.__assign({ className: classPrefix + "-form-check--table-select" }, props), children));
}
//# sourceMappingURL=selectable.js.map