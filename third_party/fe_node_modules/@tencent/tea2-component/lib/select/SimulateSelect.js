"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importStar(require("react"));
var dropdown_1 = require("../dropdown");
var i18n_1 = require("../i18n");
var form_1 = require("../form");
var searchbox_1 = require("../searchbox");
var tips_1 = require("../tips");
var text_1 = require("../text");
var key_code_1 = require("../_util/key-code");
var VirtualizedList_1 = require("../list/VirtualizedList");
var inject_value_1 = require("../_util/inject-value");
var use_default_1 = require("../_util/use-default");
var noop_1 = require("../_util/noop");
/**
 * 模拟 Select
 */
function SimulateSelect(props) {
    var t = i18n_1.useTranslation();
    var _a = form_1.useDefaultValue(props, null), value = _a.value, onChange = _a.onChange, _b = _a.options, options = _b === void 0 ? [] : _b, _c = _a.groups, groups = _c === void 0 ? {} : _c, _d = _a.placeholder, placeholder = _d === void 0 ? t.pleaseSelect : _d, button = _a.button, size = _a.size, onScrollBottom = _a.onScrollBottom, listHeight = _a.listHeight, bottomTips = _a.bottomTips, _e = _a.boxStyle, boxStyle = _e === void 0 ? {} : _e, _f = _a.onOpen, onOpen = _f === void 0 ? noop_1.noop : _f, _g = _a.onClose, onClose = _g === void 0 ? noop_1.noop : _g, searchable = _a.searchable, _h = _a.searchPlaceholder, searchPlaceholder = _h === void 0 ? "" : _h, _j = _a.onSearch, onSearch = _j === void 0 ? noop_1.noop : _j, customizeFilter = _a.filter, _k = _a.defaultSearchValue, defaultSearchValue = _k === void 0 ? "" : _k, searchValue = _a.searchValue, onSearchValueChange = _a.onSearchValueChange, _l = _a.autoClearSearchValue, autoClearSearchValue = _l === void 0 ? true : _l, clearable = _a.clearable, _m = _a.appearance, appearance = _m === void 0 ? props.appearence : _m, // eslint-disable-line react/destructuring-assignment
    dropdownProps = tslib_1.__rest(_a, ["value", "onChange", "options", "groups", "placeholder", "button", "size", "onScrollBottom", "listHeight", "bottomTips", "boxStyle", "onOpen", "onClose", "searchable", "searchPlaceholder", "onSearch", "filter", "defaultSearchValue", "searchValue", "onSearchValueChange", "autoClearSearchValue", "clearable", "appearance"]);
    var dropdownRef = react_1.useRef(null);
    var listRef = react_1.useRef(null);
    var _o = tslib_1.__read(react_1.useState(0), 2), currentIndex = _o[0], setCurrentIndex = _o[1];
    var InputRef = react_1.useRef(null);
    var _p = tslib_1.__read(use_default_1.useDefault(searchValue, defaultSearchValue, onSearchValueChange), 2), inputValue = _p[0], setInputValue = _p[1];
    var filter = customizeFilter ||
        (function (inputValue, _a) {
            var text = _a.text, value = _a.value;
            var optionText = String(typeof text === "string" ? text : value);
            return !searchable || optionText.includes(inputValue);
        });
    function focus() {
        if (searchable) {
            setTimeout(function () {
                if (InputRef.current) {
                    InputRef.current.focus();
                }
            }, 100); // 第一次展开时 Input 还未渲染
        }
    }
    var selected = value != null ? options.find(function (x) { return x.value === value; }) : undefined;
    // 选项消失不影响已选中值显示
    var _q = tslib_1.__read(react_1.useState(function () {
        if (!selected) {
            return undefined;
        }
        return selected;
    }), 2), buttonOption = _q[0], setButtonOption = _q[1];
    // options 中有选中项时改变 buttonOption
    react_1.useEffect(function () {
        if (selected) {
            setButtonOption(selected);
        }
    }, [options]); // eslint-disable-line react-hooks/exhaustive-deps
    // value 变化时改变 buttonOption 及搜索框状态
    react_1.useEffect(function () {
        if (selected) {
            setButtonOption(selected);
        }
        else {
            setButtonOption(undefined);
        }
    }, [value]); // eslint-disable-line react-hooks/exhaustive-deps
    var buttonPlaceholder = placeholder;
    if (!appearance || appearance === "button" || appearance === "default") {
        buttonPlaceholder = react_1.default.createElement(text_1.Text, { theme: "weak" }, placeholder);
    }
    // 按钮文字
    var buttonText = 
    // eslint-disable-next-line no-nested-ternary
    buttonOption
        ? typeof buttonOption.text === "undefined"
            ? buttonOption.value
            : buttonOption.text
        : buttonPlaceholder || t.pleaseSelect;
    var hasGroup = !!options.find(function (opt) { return !!opt.groupKey; });
    // 筛选
    var filteredOptions = options.filter(function (options) {
        return filter(inputValue, options);
    });
    // 提示
    var tips = props.tips;
    if (typeof tips === "undefined" && filteredOptions.length === 0) {
        tips = react_1.default.createElement(tips_1.EmptyTip, null);
    }
    var items = getListItems({
        tips: inject_value_1.injectValue(tips)(filteredOptions),
        bottomTips: inject_value_1.injectValue(bottomTips)(filteredOptions),
        groups: groups,
        options: filteredOptions,
    });
    var count = items.length;
    function handleKeyDown(source, event, 
    // input 托管事件时没有 context，此时一定为 open 状态
    context, close) {
        if (context === void 0) { context = { open: true }; }
        if (close === void 0) { close = function () { return null; }; }
        var getOptionIndex = function (current, step) {
            if (step === void 0) { step = 1; }
            var flag = 1;
            var index = (current + step + count) % count;
            var item = items[index % count];
            while (flag < count && item.type !== "option") {
                flag += 1;
                index = (index + step + count) % count;
                item = items[index % count];
            }
            return index;
        };
        var ok = function () {
            var item = items[currentIndex % count];
            if (item && item.type === "option" && context.open) {
                // 输入时不能使用空格选中
                if (item.option.disabled) {
                    return false;
                }
                onChange(item.option.value, { event: event });
                close();
            }
            return true;
        };
        switch (event.keyCode) {
            case key_code_1.KeyCode.Space:
                if (source === "input") {
                    return false;
                }
                event.preventDefault();
                return ok();
            case key_code_1.KeyCode.Enter:
                return ok();
            case key_code_1.KeyCode.Up:
                event.preventDefault();
                setCurrentIndex(function (c) {
                    var index = getOptionIndex(c, -1);
                    if (listRef.current) {
                        listRef.current.scrollToItem(index);
                    }
                    return index;
                });
                break;
            case key_code_1.KeyCode.Down:
                event.preventDefault();
                setCurrentIndex(function (c) {
                    var index = getOptionIndex(c);
                    if (listRef.current) {
                        listRef.current.scrollToItem(index);
                    }
                    return index;
                });
                break;
            case key_code_1.KeyCode.Esc:
                close();
                break;
        }
        return true;
    }
    return (react_1.default.createElement(dropdown_1.Dropdown, tslib_1.__assign({ updateOnChildrenChange: true, ref: dropdownRef, clickClose: false, size: size, boxStyle: boxStyle, appearance: appearance, button: typeof button !== "undefined"
            ? inject_value_1.injectValue(button)(buttonOption)
            : buttonText, onOpen: function () {
            onOpen();
            focus();
        }, onClose: function () {
            onClose();
            // 已经未空值不再次置回初始
            if (autoClearSearchValue) {
                setTimeout(function () {
                    setInputValue("", {});
                }, 100);
            }
            if (dropdownRef.current) {
                dropdownRef.current.focus();
            }
        }, onKeyDown: function (event, context) { return handleKeyDown("dropdown", event, context); }, clearable: buttonOption && clearable, onClear: function (event) {
            onChange(null, { event: event });
            setButtonOption(null);
        } }, dropdownProps), function (close) { return (react_1.default.createElement(react_1.default.Fragment, null,
        searchable && (react_1.default.createElement(searchbox_1.SearchBox, { simple: true, ref: InputRef, value: inputValue, onChange: function (value, context) {
                setInputValue(value, context);
                onSearch(value, context);
            }, onClear: focus, placeholder: searchPlaceholder, onKeyDown: function (event) {
                return handleKeyDown("input", event, undefined, close);
            }, onSearch: onSearch })),
        react_1.default.createElement(VirtualizedList_1.VirtualizedList, { containerStyle: boxStyle, containerClassName: dropdownProps.boxClassName, items: items.map(function (item, index) {
                if (item.type === "option") {
                    var option_1 = item.option;
                    return tslib_1.__assign(tslib_1.__assign({}, item), { props: {
                            disabled: option_1.disabled,
                            selected: option_1 === selected,
                            current: option_1 !== selected && currentIndex % count === index,
                            onClick: function (event) {
                                onChange(option_1.value, { event: event });
                                close();
                            },
                            tooltip: option_1.tooltip,
                        } });
                }
                return item;
            }), virtualizedRef: listRef, type: hasGroup ? "option-group" : "option", onScrollBottom: onScrollBottom, listHeight: listHeight }))); }));
}
exports.SimulateSelect = SimulateSelect;
function getListItems(_a) {
    var tips = _a.tips, bottomTips = _a.bottomTips, options = _a.options, groups = _a.groups;
    var items = [];
    // tips
    if (tips) {
        items.push({ type: "tips", key: "__tips", text: tips });
    }
    // option/group
    options.forEach(function (option, index) {
        if (option.groupKey &&
            (index === 0 || option.groupKey !== options[index - 1].groupKey)) {
            items.push({
                type: "group",
                key: option.groupKey + "-" + option.value,
                text: groups[option.groupKey],
            });
        }
        items.push({
            type: "option",
            key: option.value,
            text: typeof option.text === "undefined" ? option.value : option.text,
            option: option,
        });
    });
    // bottomTips
    if (bottomTips) {
        items.push({ type: "tips", key: "__bottom_tips", text: bottomTips });
    }
    return items;
}
//# sourceMappingURL=SimulateSelect.js.map